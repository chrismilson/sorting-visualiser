{"version":3,"sources":["sort/types.ts","ui/components/Display.tsx","ui/components/Button.tsx","ui/components/Menu.tsx","ui/hooks/use-values.ts","sort/algorithms/unsort/common.ts","sort/algorithms/unsort/index.ts","sort/algorithms/unsort/cut.ts","sort/algorithms/unsort/hindu-shuffle.ts","sort/algorithms/unsort/overhand-shuffle.ts","sort/algorithms/unsort/perfect-riffle-shuffle.ts","sort/algorithms/unsort/randomise.ts","sort/algorithms/unsort/reverse.ts","sort/algorithms/unsort/riffle-shuffle.ts","sort/algorithms/sort/binary-insertion-sort.ts","sort/algorithms/sort/bubble-sort.ts","sort/algorithms/sort/heap-sort.ts","sort/algorithms/sort/merge-sort.ts","sort/algorithms/sort/quick-sort.ts","sort/algorithms/sort/shell-sort.ts","sort/algorithms/sort/tim-sort.ts","sort/algorithms/sort/index.ts","sort/Untracker.ts","sort/Tracker.ts","ui/hooks/use-algorithms.ts","ui/hooks/use-toggle.ts","ui/hooks/use-block.ts","ui/App.tsx","index.tsx"],"names":["MoveType","Direction","Display","props","values","moveRef","untracker","draw","useCallback","ctx","canvas","width","height","length","setTransform","fillStyle","currentValues","forEach","value","index","fillRect","frame","drawFrame","requestAnimationFrame","i","clearRect","forEachInExtra","_buffer","save","globalAlpha","NaN","restore","move","current","type","SWAP","j","COMPARE","result","color","MEMCPY","from","to","drawMove","cancelAnimationFrame","canvasRef","useCanvas","className","ref","Button","name","handler","disabled","keyStr","keyCode","children","buttonAttributes","camelCaseName","replace","_x","y","toLowerCase","toUpperCase","useRef","useEffect","undefined","listener","e","key","click","preventDefault","window","addEventListener","removeEventListener","title","onClick","IconButton","Icon","Menu","reverse","reverseStatus","status","restart","speedDown","stepBack","play","playStatus","stepForward","speedUp","sizeUp","sizeDown","unsort","sort","useState","spinning","setSpinning","extra","setExtra","FaRedoAlt","style","transition","transform","onTransitionEnd","FaBackward","FaStepBackward","FaPause","FaPlay","FaSyncAlt","FaStepForward","FaForward","FaEllipsisV","list","map","camelCase","FaPlus","FaMinus","useValues","size","useMemo","push","randomNormal","mean","stddev","u","v","Math","random","normal","sqrt","log","cos","PI","boundAndRound","min","target","max","round","algorithms","cut","malloc","memcpy","free","split","buffer","hinduShuffle","group","start","overhandShuffle","processed","perfectRiffleShuffle","halfSize","firstHalf","secondHalf","destination","randomise","swap","floor","riffleShuffle","pA","pB","dest","binaryInsertionSort","compare","findIndex","low","high","mid","bubbleSort","heapSort","heapify","extreme","left","right","mergeSort","k","merge","quickSort","pivot","partition","shellSort","gap","MergeState","pending","minGallop","timsort","countRun","n","gallopLeft","mark","hint","fromBuffer","indexFrom","base","lastOffset","offset","maxOffset","temp","gallopRight","binarySearch","shift","insertionSort","mergeLo","mergeState","nA","nB","countA","countB","gallop","mergeHi","mergeAt","len","splice","ignoreAtFront","mergeCollapse","remaining","MIN_RUN","r","calculateMinRun","mergeForceCollapse","Untracker","moves","original","buffers","bufferIds","currentMove","this","0","Set","hasNext","bind","hasPrevious","next","previous","reset","MALLOC","add","FREE","delete","id","direction","FORWARD","stepsPerFrame","options","onCompletion","step","withRecord","withAnimationFrame","run","hasStep","withInterval","interval","setInterval","clearInterval","timeUntilCompletion","stepsRemaining","animateStepsPerFrame","callback","Symbol","iterator","BufferIdPool","_next","_inUse","has","Tracker","bufferIdPool","iIndex","jIndex","normaliseIndex","iBuffer","jBuffer","sign","Array","useAlgorithms","unsortedValues","setUnsortedValues","unsortWith","block","unblock","unsortingAlgorithms","copy","tracker","untrack","animateUntilCompletion","sortString","setSortString","sortUntracker","setSortUntracker","invalid","a","sortingAlgorithms","calculate","then","setSort","useToggle","first","second","setValue","toggle","firstOrSecond","useBlock","count","setCount","blocking","App","BACKWARD","changeDirection","setPlay","speed","setSpeed","setSize","pow","oppositeDirection","Object","keys","algorithm","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.1c44a2f5.chunk.js","sourcesContent":["import Tracker from './Tracker'\n\n/** The type that each sorting algorithm should implement */\nexport type Algorithm = (tracker: Tracker) => void\n\n/** The different types of moves an algorithm can use */\nexport enum MoveType {\n  SWAP = 'SWAP',\n  COMPARE = 'COMPARE',\n  MALLOC = 'MALLOC',\n  MEMCPY = 'MEMCPY',\n  FREE = 'FREE'\n}\n\n/**\n * Represents an index in an allocated buffer.\n */\nexport type Index = { buffer: number; index: number }\n\nexport interface SwapMove {\n  type: MoveType.SWAP\n  i: Index & { value: number }\n  j: Index & { value: number }\n}\n\nexport interface CompareMove {\n  type: MoveType.COMPARE\n  i: Index & { value: number }\n  j: Index & { value: number }\n  result: number\n}\n\nexport interface MallocMove {\n  type: MoveType.MALLOC\n  size: number\n  buffer: number\n}\n\nexport interface MemcpyMove {\n  type: MoveType.MEMCPY\n  from: Index\n  to: Index\n  value: number\n  original: number\n}\n\nexport interface FreeMove {\n  type: MoveType.FREE\n  buffer: number\n}\n\nexport type Move = SwapMove | CompareMove | MallocMove | MemcpyMove | FreeMove\n\n/** Represents the direction of flow of an algorithm */\nexport enum Direction {\n  FORWARD = 'FORWARD',\n  BACKWARD = 'BACKWARD'\n}\n","import React, { useCallback } from 'react'\nimport useCanvas, { DrawingMethod } from 'react-hooks-use-drawing-canvas'\nimport { MoveType, Move } from '../../sort/types'\nimport Untracker from '../../sort/Untracker'\nimport './Display.scss'\n\n/** continuously displays values on the screen */\nconst Display: React.FC<{\n  values: number[]\n  moveRef: React.MutableRefObject<Move | undefined>\n  untracker?: Untracker\n}> = props => {\n  const { values, moveRef, untracker } = props\n\n  const draw = useCallback<DrawingMethod>(\n    ctx => {\n      // resize the pixels, not just a maths transform\n      ctx.canvas.width = ctx.canvas.height = values.length\n      ctx.setTransform(1, 0, 0, -1, 0, values.length)\n\n      ctx.fillStyle = 'rgb(87,163,207)'\n\n      const currentValues = [...values]\n      values.forEach((value, index) => {\n        ctx.fillRect(index, 0, 1, value)\n      })\n\n      const drawMove = () => {\n        const move = moveRef.current\n        if (!move) return\n        switch (move.type) {\n          case MoveType.SWAP:\n            {\n              const { i, j } = move\n              ctx.save()\n              ctx.fillStyle = 'cyan'\n              ctx.fillRect(i.index, 0, 1, j.value)\n              ctx.fillRect(j.index, 0, 1, i.value)\n              ctx.restore()\n\n              // We make sure that the values are repainted on the next frame by\n              // setting the current value to NaN.\n              currentValues[i.index] = currentValues[j.index] = NaN\n            }\n            break\n          case MoveType.COMPARE:\n            {\n              const { i, j, result } = move\n\n              const color = ['lime', 'orange', 'red']\n              ctx.save()\n              ctx.fillStyle = color[1 + result]\n              ctx.fillRect(i.index, 0, 1, i.value)\n\n              ctx.fillStyle = color[1 - result]\n              ctx.fillRect(j.index, 0, 1, j.value)\n              ctx.restore()\n\n              currentValues[i.index] = currentValues[j.index] = NaN\n            }\n            break\n          case MoveType.MEMCPY:\n            {\n              const { from, to, value } = move\n\n              ctx.save()\n              ctx.fillStyle = 'gold'\n              ctx.fillRect(from.index, 0, 1, value)\n              ctx.fillRect(to.index, 0, 1, value)\n              ctx.restore()\n\n              currentValues[from.index] = currentValues[to.index] = NaN\n            }\n            break\n        }\n      }\n\n      let frame: number\n      const drawFrame = () => {\n        frame = requestAnimationFrame(drawFrame)\n        // check the main values\n        for (let i = 0; i < values.length; i++) {\n          if (currentValues[i] !== values[i]) {\n            ctx.clearRect(i, 0, 1, values.length)\n            ctx.fillRect(i, 0, 1, values[i])\n            currentValues[i] = values[i]\n          }\n        }\n\n        // then the extra memory\n        untracker?.forEachInExtra((_buffer, index, value) => {\n          ctx.save()\n          ctx.globalAlpha = 0.2\n          ctx.fillStyle = 'purple'\n\n          ctx.fillRect(index, 0, 1, value)\n          // repaint the extra values each time\n          currentValues[index] = NaN\n\n          ctx.restore()\n        })\n\n        drawMove()\n      }\n\n      drawFrame()\n\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    },\n    [values, moveRef, untracker]\n  )\n\n  const canvasRef = useCanvas(draw)\n\n  return <canvas className=\"Display\" ref={canvasRef} />\n}\n\nexport default Display\n","import React, { useRef, useEffect } from 'react'\nimport { IconType } from 'react-icons/lib/cjs'\nimport './Button.scss'\n\ntype ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n  name: string\n  handler: () => void\n  disabled?: boolean\n  keyStr?: string\n  keyCode?: number\n}\n\nconst Button: React.FC<ButtonProps> = ({\n  name,\n  handler,\n  disabled,\n  keyStr,\n  keyCode,\n  children,\n  className,\n  ...buttonAttributes\n}) => {\n  const camelCaseName = name\n    .replace(/^(.)/, (_x, y) => y.toLowerCase())\n    .replace(/ (.)/g, (_x, y) => y.toUpperCase())\n\n  // We want to make it possible to specify a keyboard event that will also fire\n  // the button.\n  const ref = useRef<HTMLButtonElement>(null)\n  useEffect(() => {\n    if (keyStr !== undefined || keyCode !== undefined) {\n      const listener = (e: KeyboardEvent) => {\n        // By clicking the button instead of calling the callback, we make sure\n        // that the callback is not fired if the button is disabled\n        if (e.key === keyStr || e.keyCode === keyCode) {\n          ref.current?.click()\n          if (e.key === ' ') e.preventDefault()\n        }\n      }\n      window.addEventListener('keydown', listener)\n      return () => {\n        window.removeEventListener('keydown', listener)\n      }\n    }\n  }, [ref, keyStr, keyCode])\n\n  return (\n    <button\n      ref={ref}\n      className={`Button ${className} ${camelCaseName}`}\n      title={name}\n      onClick={handler}\n      disabled={disabled}\n      {...buttonAttributes}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport const IconButton: React.FC<ButtonProps & { Icon: IconType }> = ({\n  Icon,\n  ...props\n}) => (\n  <Button {...props} className={`${props.className} Icon`}>\n    <Icon className=\"icon\" />\n  </Button>\n)\n\nexport default Button\n","import React, { useState } from 'react'\nimport {\n  FaRedoAlt,\n  FaBackward,\n  FaStepBackward,\n  FaPlay,\n  FaSyncAlt,\n  FaForward,\n  FaStepForward,\n  FaEllipsisV,\n  FaPlus,\n  FaMinus,\n  FaPause\n} from 'react-icons/fa'\nimport Button, { IconButton } from './Button'\nimport './Menu.scss'\n\ninterface ButtonProps {\n  handler: () => void\n  keyStr?: string\n  keyCode?: number\n  disabled?: boolean\n}\n\ninterface AlgorithmProps {\n  current: string\n  list: string[]\n  handler(key: string): void\n}\n\nconst Menu: React.FC<{\n  reverse: ButtonProps & { status: boolean }\n  restart: ButtonProps\n  speedDown: ButtonProps\n  stepBack: ButtonProps\n  play: ButtonProps & { status: boolean }\n  stepForward: ButtonProps\n  speedUp: ButtonProps\n  sizeUp: ButtonProps\n  sizeDown: ButtonProps\n  unsort: {\n    disabled: boolean\n    list: string[]\n    handler(key: string): void\n  }\n  sort: {\n    current: string\n    list: string[]\n    handler(key: string): void\n  }\n}> = ({\n  reverse: { status: reverseStatus, ...reverse },\n  restart,\n  speedDown,\n  stepBack,\n  play: { status: playStatus, ...play },\n  stepForward,\n  speedUp,\n  sizeUp,\n  sizeDown,\n  unsort,\n  sort\n}) => {\n  const [spinning, setSpinning] = useState(false)\n  const [extra, setExtra] = useState(false)\n\n  return (\n    <div className=\"Menu\">\n      <IconButton\n        name=\"restart\"\n        Icon={FaRedoAlt}\n        style={\n          spinning\n            ? {\n                transition: 'transform 300ms',\n                transform: `rotate(${360}deg)`\n              }\n            : {}\n        }\n        onTransitionEnd={() => setSpinning(false)}\n        {...restart}\n        handler={() => {\n          restart.handler()\n          setSpinning(true)\n        }}\n      />\n      <IconButton name=\"speed down\" Icon={FaBackward} {...speedDown} />\n      <IconButton name=\"step back\" Icon={FaStepBackward} {...stepBack} />\n      <div className=\"playPauseWithReverse\">\n        <IconButton\n          name=\"play\"\n          Icon={playStatus ? FaPause : FaPlay}\n          style={{\n            transition: 'transform 100ms',\n            transform: `rotate(${reverseStatus ? 180 : 0}deg)`\n          }}\n          {...play}\n        />\n        <IconButton name=\"reverse\" Icon={FaSyncAlt} {...reverse} />\n      </div>\n      <IconButton name=\"step forward\" Icon={FaStepForward} {...stepForward} />\n      <IconButton name=\"speed up\" Icon={FaForward} {...speedUp} />\n      <div className={`extra ${extra ? 'show' : 'hide'}`}>\n        <IconButton\n          name=\"extra options\"\n          Icon={FaEllipsisV}\n          keyCode={27}\n          handler={() => setExtra(!extra)}\n        />\n        <div className=\"buttons\">\n          <div className=\"algorithms\">\n            <div className=\"unsort\">\n              {unsort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    unsort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  disabled={unsort.disabled}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n            <div className=\"sort\">\n              {sort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    setExtra(false)\n                    sort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  className={sort.current === camelCase ? 'active' : ''}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n          </div>\n          <IconButton name=\"size up\" Icon={FaPlus} {...sizeUp} />\n          <IconButton name=\"size down\" Icon={FaMinus} {...sizeDown} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default Menu\n","import { useMemo } from 'react'\n\n/**\n * Supplies an array of length `size` with evenly spaced values in (0, 1].\n *\n * The array reference will change when the size changes.\n */\nconst useValues = (size: number) => {\n  return useMemo(() => {\n    const values = []\n\n    for (let i = 1; i <= size; i++) values.push(i)\n\n    return values\n  }, [size])\n}\n\nexport default useValues\n","export const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const normal = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v)\n  return normal * stddev + mean\n}\n\nexport const boundAndRound = (min: number, target: number, max: number) => {\n  return Math.max(min, Math.min(max, Math.round(target)))\n}\n","import { Algorithm } from '../../types'\nimport cut from './cut'\nimport hinduShuffle from './hindu-shuffle'\nimport overhandShuffle from './overhand-shuffle'\nimport perfectRiffleShuffle from './perfect-riffle-shuffle'\nimport randomise from './randomise'\nimport reverse from './reverse'\nimport riffleShuffle from './riffle-shuffle'\n\nconst algorithms: { [key: string]: Algorithm } = {\n  cut,\n  hinduShuffle,\n  overhandShuffle,\n  perfectRiffleShuffle,\n  randomise,\n  reverse,\n  riffleShuffle\n}\n\nexport default algorithms\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst cut: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 6), size)\n\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n  for (let i = 0; i < size - split; i++) memcpy(split + i, i)\n  for (let i = 0; i < split; i++) memcpy({ buffer, index: i }, size - split + i)\n\n  free(buffer)\n}\n\nexport default cut\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst hinduShuffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  // determine the size of the group to be pulled\n  const group = boundAndRound(0, randomNormal(size / 5, size / 30), size - 1)\n\n  // then determine the first index\n  const start = boundAndRound(\n    0,\n    randomNormal((size - group) / 2, (size - group) / 6),\n    size - group\n  )\n\n  const buffer = malloc(group)\n\n  for (let i = 0; i < group; i++) memcpy(start + i, { buffer, index: i })\n  for (let i = 0; i < start; i++) memcpy(start - i - 1, start + group - i - 1)\n  for (let i = 0; i < group; i++) memcpy({ buffer, index: i }, i)\n\n  free(buffer)\n}\n\nexport default hinduShuffle\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\n/**\n * This shuffle is supposed to represent the normal shuffle that people do with\n * playing cards, and attempts to show the drawbacks of not shuffling properly.\n *\n * You will notice that runs often stay together, and the general order of the\n * entire array tends to reverse after each round\n */\nconst overhand: Algorithm = ({ malloc, memcpy, free, size }) => {\n  let processed = 0\n\n  while (processed < size) {\n    const group = Math.min(\n      size - processed,\n      boundAndRound(0, randomNormal(size / 7, size / 20), size)\n    )\n\n    const buffer = malloc(group)\n    // Copy the group into memory from the back\n    for (let i = 0; i < group; i++) {\n      memcpy(size - group + i, { buffer, index: i })\n    }\n    // Shift the remaining values\n    for (let i = 0; i < size - processed - group; i++) {\n      memcpy(size - group - i - 1, size - i - 1)\n    }\n    // Put the group at the front\n    for (let i = 0; i < group; i++) {\n      memcpy({ buffer, index: i }, processed + i)\n    }\n\n    free(buffer)\n    processed += group\n  }\n}\n\nexport default overhand\n","import { Algorithm } from '../../types'\n\nconst perfectRiffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const halfSize = size >> 1\n  const buffer = malloc(halfSize)\n  for (let i = 0; i < halfSize; i++) memcpy(i, { buffer, index: i })\n\n  let firstHalf = 0\n  let secondHalf = halfSize\n  let destination = 0\n  while (firstHalf < halfSize && secondHalf < size) {\n    memcpy({ buffer, index: firstHalf++ }, destination++)\n    memcpy(secondHalf++, destination++)\n  }\n  free(buffer)\n}\n\nexport default perfectRiffle\n","import { Algorithm } from '../../types'\n\n/**\n * This algorithm does not sort an array - it shuffles an array. The original\n * values will be created sorted; this algorithm will then *un-sort* the values\n * before one of the actual algorithms can sort it.\n */\nconst shuffle: Algorithm = ({ swap, size }) => {\n  for (let i = 0; i < size; i++) {\n    const j = i + Math.floor(Math.random() * (size - i))\n    swap(i, j)\n  }\n}\n\nexport default shuffle\n","import { Algorithm } from '../../types'\n\n/**\n * Does what it says on the tin.\n */\nconst reverse: Algorithm = ({ swap, size }) => {\n  for (let i = 0; i < Math.floor(size / 2); i++) {\n    swap(i, size - i - 1)\n  }\n}\n\nexport default reverse\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst riffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 10), size)\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n\n  let pA = 0\n  let pB = split\n  let dest = 0\n\n  while (pA < split && pB < size) {\n    if (Math.random() > 0.5) {\n      memcpy({ buffer, index: pA++ }, dest++)\n    } else {\n      memcpy(pB++, dest++)\n    }\n  }\n  // the rest of B is already at the end.\n  while (pA < split) memcpy({ buffer, index: pA++ }, dest++)\n\n  free(buffer)\n}\n\nexport default riffle\n","import { Algorithm } from '../../types'\n\nconst binaryInsertionSort: Algorithm = ({ compare, swap, size }) => {\n  const findIndex = (target: number) => {\n    let low = 0\n    let high = target\n\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n      if (compare(target, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  for (let i = 1; i < size; i++) {\n    const index = findIndex(i)\n    for (let j = i; j > index; j--) {\n      swap(j, j - 1)\n    }\n  }\n}\n\nexport default binaryInsertionSort\n","import { Algorithm } from '../../types'\n\n/**\n * Bubble sort is a sorting algorithm that will sort an array of n comparable\n * elements.\n *\n * Bubble sort works by checking adjacent values. If the right value is less\n * than the left value, it swaps them. Otherwise it leaves them alone.\n *\n * After one pass of the entire array from the end to the beginning, the\n * smallest element in the array will be at the front. Then the pairs are all\n * checked again (but not the definitely sorted part).\n *\n * Since we only have one element sorted each pass, we will have to make a pass\n * for each (next smallest) element in the array, leading to a 'sum of the\n * numbers up to n' style time complexity, which is O(n^2).\n *\n * The space complexity however is very simple, we only keep track of the number\n * of definitely sorted values and our position in the current pass. This means\n * we have O(1) space complexity.\n * @param tracker\n */\nconst bubbleSort: Algorithm = ({ swap, compare, size }) => {\n  for (let i = 0; i < size - 1; i++) {\n    for (let j = size - 1; j > i; j--) {\n      if (compare(j, j - 1) < 0) swap(j, j - 1)\n    }\n  }\n}\n\nexport default bubbleSort\n","import { Algorithm } from '../../types'\n\nconst heapSort: Algorithm = ({ compare, swap, size }) => {\n  const heapify = (current: number, max: number) => {\n    let extreme, left, right\n\n    while (current < max) {\n      extreme = current\n      left = 2 * current + 1\n      right = 2 * current + 2\n\n      if (left < max && compare(extreme, left) < 0) extreme = left\n      if (right < max && compare(extreme, right) < 0) extreme = right\n\n      if (extreme === current) return\n      swap(current, extreme)\n      current = extreme\n    }\n  }\n\n  for (let i = 0; i < size; i++) heapify(size - i - 1, size)\n\n  for (let i = 0; i < size; i++) {\n    swap(0, size - i - 1)\n    heapify(0, size - i - 1)\n  }\n}\n\nexport default heapSort\n","import { Algorithm } from '../../types'\n\nconst mergeSort: Algorithm = ({ compare, malloc, memcpy, free, size }) => {\n  const merge = (low: number, mid: number, high: number) => {\n    const buffer = malloc(high - low)\n\n    let index = 0\n    let i = low\n    let j = mid\n    while (i < mid && j < high) {\n      if (compare(i, j) < 0) memcpy(i++, { buffer, index })\n      else memcpy(j++, { buffer, index })\n      index += 1\n    }\n    // copy remaining values to the end\n    if (i < mid) {\n      for (let k = i; k < mid; k++) {\n        memcpy(k, high - mid + k)\n      }\n    }\n    // copy back from memory\n    while (index--) {\n      memcpy({ buffer, index }, low + index)\n    }\n\n    free(buffer)\n  }\n\n  const split = (low: number, high: number) => {\n    const mid = low + Math.floor((high - low) / 2)\n\n    if (low < mid) {\n      split(low, mid)\n      split(mid, high)\n      merge(low, mid, high)\n    }\n  }\n  split(0, size)\n}\n\nexport default mergeSort\n","import { Algorithm } from '../../types'\n\n/**\n * Quick sort is a recursive sorting algorithm that will sort an array of `n`\n * comparable elements.\n *\n * Quick sort works on subarrays:\n * - It chooses a \"pivot\", any single element in the subarray. The pivot can be\n *   chosen arbitrarily, but difference choices will lead to different runtimes\n *   on different data.\n * - It then partitions the subarray into three portions:\n *   - A subarray of the elements less than or equal to than the pivot;\n *   - The pivot; and,\n *   - A subarray of the elements larger than the pivot.\n * - Then it runs the algorithm again on the two subarrays.\n *\n * Since the subarrays are smaller, the depth will be at most the length of the\n * array (if the smallest value in the array is the first element in every\n * subarray; the array was sorted already) and the sort will finish. Giving us a\n * worst case of O(n^2) time complexity.\n *\n * On average for random data however the split will be closer to the middle and\n * in the best case we will have half the values in each part. Thus in our best\n * case we will have O(n log(n)) time complexity.\n *\n * Since we are recursing, we will have O(1) space for each layer in the\n * recursion, so the worst case for our space complexity will be O(n).\n *\n * In the best case however we will have less layers alive at any one time,\n * meaning our space complexity would be O(log(n)).\n */\nconst quickSort: Algorithm = ({ swap, compare, size }) => {\n  const partition = (low: number, high: number) => {\n    const pivot = low\n\n    let i = high\n    for (let j = high; j > pivot; j--) {\n      if (compare(pivot, j) < 0) swap(j, i--)\n    }\n\n    swap(pivot, i)\n    return i\n  }\n\n  const sort = (low: number, high: number) => {\n    if (low < high) {\n      const mid = partition(low, high)\n      sort(low, mid - 1)\n      sort(mid + 1, high)\n    }\n  }\n\n  sort(0, size - 1)\n}\n\nexport default quickSort\n","import { Algorithm } from '../../types'\n\nconst shellSort: Algorithm = ({ compare, swap, size }) => {\n  let gap = ~~(size / 2)\n\n  while (gap > 0) {\n    for (let i = gap; i < size; i++) {\n      for (let j = i; j >= gap && compare(j - gap, j) > 0; j -= gap) {\n        swap(j - gap, j)\n      }\n    }\n    gap = ~~(gap / 2)\n  }\n}\n\nexport default shellSort\n","import { Algorithm, Index } from '../../types'\n\ninterface Slice {\n  base: number\n  len: number\n}\n\nclass MergeState {\n  pending: Slice[] = []\n  minGallop = 7\n}\n\n/**\n * Adapted from the listsort algorithm in python\n * http://svn.python.org/projects/python/trunk/Objects/listobject.c\n */\nconst timsort: Algorithm = ({ compare, swap, malloc, memcpy, free, size }) => {\n  /**\n   * Returns the length of a run starting at a given index (up to a given\n   * index).\n   *\n   * If the run is descending the value will be the negative length of the run.\n   */\n  const countRun = (low: number, high: number) => {\n    if (low === high - 1) return 1\n    let n = low + 1\n    if (compare(low, n) > 0) {\n      while (n < high && compare(n - 1, n) > 0) n++\n      // returns negative to signify decending run\n      return low - n\n    }\n    while (n < high && compare(n - 1, n) <= 0) n++\n    return n - low\n  }\n\n  /**\n   * Simmilar to binary search, except first finds a good lower and upper bound\n   * before searching.\n   */\n  const gallopLeft = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      // mark should be somwhere in [hint, size]\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset = hint + lastOffset\n      offset = hint + offset\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n    return offset\n  }\n\n  const gallopRight = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    /** optionally set the buffer that from should access */\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset += hint\n      offset += hint\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n\n    return offset\n  }\n\n  /**\n   * Finds the index of a value (or the index a value should be inserted at) in\n   * sorted data.\n   */\n  const binarySearch = (low: number, high: number, mark: number) => {\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n\n      if (compare(mark, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  /**\n   * Shifts values to the right, wrapping the last value to the front.\n   */\n  const shift = (low: number, high: number) => {\n    for (let i = high; i > low; i--) swap(i - 1, i)\n  }\n\n  /**\n   * Performs a binary insertion sort on a chunk.\n   */\n  const insertionSort = (low: number, high: number) => {\n    for (let i = low; i < high; i++) shift(binarySearch(low, i, i), i)\n  }\n\n  /**\n   * Reverses a chunk.\n   */\n  const reverse = (low: number, high: number) => {\n    const mid = Math.floor((high - low) / 2)\n    for (let i = 0; i < mid; i++) swap(low + i, high - i - 1)\n  }\n\n  /**\n   * Timsort's merge low method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeLo = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the A buffer into extra memory\n    const buffer = malloc(nA)\n    for (let index = 0; index < nA; index++) {\n      memcpy(pA + index, { buffer, index })\n    }\n\n    let destination = pA\n    pA = 0 // this is now the index in extra memory\n    let countA = 0\n    let countB = 0\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n\n        countA = gallopRight(pB, pA, nA, 0, buffer)\n        for (let i = 0; i < countA; i++) {\n          memcpy({ buffer, index: pA++ }, destination++)\n        }\n        nA -= countA\n        // if (nA === 0) return\n\n        countB = gallopLeft({ buffer, index: pA }, pB, nB, 0)\n        for (let i = 0; i < countB; i++) {\n          memcpy(pB++, destination++)\n        }\n        nB -= countB\n        // if (nB === 0) return\n      }\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: pA }, pB) < 0) {\n        memcpy({ buffer, index: pA++ }, destination++)\n        nA -= 1\n        countA += 1\n        countB = 0\n      } else {\n        memcpy(pB++, destination++)\n        nB -= 1\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n\n    while (nA-- > 0) memcpy({ buffer, index: pA++ }, destination++)\n\n    free(buffer)\n  }\n\n  /**\n   * Timsort's merge high method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeHi = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the B buffer into memory\n    const buffer = malloc(nB)\n    for (let index = 0; index < nB; index++) {\n      memcpy(pB + index, { buffer, index })\n    }\n\n    let destination = pB + nB\n    let countA = 0 // number of times A won in a row\n    let countB = 0 // number of times B won in a row\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n        countA = nA - gallopRight({ buffer, index: nB - 1 }, pA, nA, nA - 1)\n        for (let i = 0; i < countA; i++) {\n          memcpy(pA + --nA, --destination)\n        }\n        // if (nA === 0) return\n\n        countB = nB - gallopLeft(pA + nA - 1, 0, nB, nB - 1, buffer)\n        for (let i = 0; i < countB; i++) {\n          memcpy({ buffer, index: --nB }, --destination)\n        }\n        // if (nB === 0) return\n      }\n      // punishment for not gallopping anymore\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: nB - 1 }, pA + nA - 1) <= 0) {\n        memcpy(pA + --nA, --destination)\n        countA += 1\n        countB = 0\n      } else {\n        memcpy({ buffer, index: --nB }, --destination)\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n    while (nB > 0) memcpy({ buffer, index: --nB }, --destination)\n\n    free(buffer)\n  }\n\n  /** Merges two slices */\n  const mergeAt = (mergeState: MergeState, i: number) => {\n    const { pending } = mergeState\n    let pA = pending[i].base\n    let nA = pending[i].len\n    const pB = pending[i + 1].base\n    let nB = pending[i + 1].len\n\n    // record the length of the combined runs.\n    pending[i].len = nA + nB\n    // remove the chunk that will be merged.\n    pending.splice(i + 1, 1)\n\n    // Where does b start in a? Elements before that can be ignored.\n    const ignoreAtFront = gallopRight(pB, pA, nA, 0)\n    pA += ignoreAtFront\n    nA -= ignoreAtFront\n\n    nB = gallopLeft(pA + nA - 1, pB, nB, nB - 1)\n\n    const merge = nA <= nB ? mergeLo : mergeHi\n    merge(mergeState, pA, nA, pB, nB)\n  }\n\n  const mergeCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len <= pending[n].len + pending[n + 1].len) {\n        if (pending[n - 1].len < pending[n + 1].len) n -= 1\n        mergeAt(mergeState, n)\n      } else if (pending[n].len <= pending[n + 1].len) {\n        mergeAt(mergeState, n)\n      } else break\n    }\n  }\n\n  const mergeForceCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len < pending[n + 1].len) n -= 1\n      mergeAt(mergeState, n)\n    }\n  }\n\n  /** Calculates the optimal minimum length of a run. */\n  const calculateMinRun = (length: number) => {\n    let r = 0 // becomes 1 if any 1 bits are shifted off.\n\n    // The true version of timsort uses 64 as a max, min size, we will use 16 so\n    // that the merging can be seen at smaller sizes\n    // while (length >= 64) {\n    while (length >= 16) {\n      r |= length & 1\n      length >>= 1\n    }\n\n    return length + r\n  }\n\n  const mergeState = new MergeState()\n  let remaining = size\n  let low = 0\n\n  const MIN_RUN = calculateMinRun(size)\n  while (remaining > 0) {\n    let n = countRun(low, size)\n\n    // reverse if descending\n    if (n < 0) {\n      n *= -1\n      reverse(low, low + n)\n    }\n\n    // exdend if too short\n    if (n < MIN_RUN) {\n      n = Math.min(MIN_RUN, remaining)\n      insertionSort(low, low + n)\n    }\n\n    // push run onto pending stack and maybe merge\n    mergeState.pending.push({\n      base: low,\n      len: n\n    })\n    mergeCollapse(mergeState)\n\n    low += n\n    remaining -= n\n  }\n  mergeForceCollapse(mergeState)\n}\n\nexport default timsort\n","import { Algorithm } from '../../types'\nimport binaryInsertionSort from './binary-insertion-sort'\nimport bubbleSort from './bubble-sort'\nimport heapSort from './heap-sort'\nimport mergeSort from './merge-sort'\nimport quickSort from './quick-sort'\nimport shellSort from './shell-sort'\nimport timsort from './tim-sort'\n\nconst algorithms: { [key: string]: Algorithm } = {\n  binaryInsertionSort,\n  bubbleSort,\n  heapSort,\n  mergeSort,\n  quickSort,\n  shellSort,\n  timsort\n}\n\nexport default algorithms\n","import { MoveType, Move, Direction } from './types'\n\n/**\n * Just as the Tracker class is for recording the algorithms. The UnTracker is\n * for replaying a tracker.\n */\nexport default class Untracker {\n  private original: number[]\n  private buffers: {\n    [key: number]: number[]\n  }\n  private bufferIds: Set<number>\n  private moves: Move[]\n  private currentMove: number\n\n  constructor(moves: Move[], values: number[], original: number[]) {\n    this.moves = moves\n    this.buffers = {\n      0: values\n    }\n    this.bufferIds = new Set()\n    this.original = original\n\n    // A tracker is not expected to undo any of the moves that were performed on\n    // the data. The untracker has to take this into account, so by default will\n    // be finished.\n    this.currentMove = 0\n\n    this.hasNext = this.hasNext.bind(this)\n    this.hasPrevious = this.hasPrevious.bind(this)\n    this.next = this.next.bind(this)\n    this.previous = this.previous.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  /** Returns true if there is a future move available to do. */\n  private hasNext() {\n    return this.currentMove < this.moves.length\n  }\n\n  /** Returns true if there is a previous move available to undo. */\n  private hasPrevious() {\n    return this.currentMove > 0\n  }\n\n  next() {\n    if (!this.hasNext()) return\n\n    const move = this.moves[this.currentMove++]\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = j.value\n          this.buffers[j.buffer][j.index] = i.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n          this.buffers[buffer] = []\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const { from, to } = move\n\n          const value = this.buffers[from.buffer][from.index]\n          this.buffers[to.buffer][to.index] = value\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  previous() {\n    if (!this.hasPrevious()) return\n\n    const move = this.moves[--this.currentMove]\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = i.value\n          this.buffers[j.buffer][j.index] = j.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const {\n            to: { buffer, index },\n            original\n          } = move\n\n          this.buffers[buffer][index] = original\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  /** Returns the values array to its original state. */\n  reset() {\n    // delete the extra buffers\n    this.bufferIds.forEach(id => {\n      delete this.buffers[id]\n    })\n\n    for (let i = 0; i < this.original.length; i++) {\n      this.buffers[0][i] = this.original[i]\n    }\n\n    this.currentMove = 0\n  }\n\n  /** Advances the untracker in a direction determined by the reverse boolean */\n  step(direction: Direction) {\n    return direction === Direction.FORWARD ? this.next() : this.previous()\n  }\n\n  /**\n   * Returns true if the untracker has a valid move available in the determined\n   * direction\n   */\n  hasStep(direction: Direction) {\n    return direction === Direction.FORWARD ? this.hasNext() : this.hasPrevious()\n  }\n\n  /**\n   * Animates the advancement of steps in a given direction.\n   *\n   * @param stepsPerFrame The number of steps to be advanced per frame\n   * @param onCompletion A callback to be run if all of the steps have been\n   * completed.\n   */\n  animateStepsPerFrame(\n    stepsPerFrame: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const { onCompletion, moveRef } = options\n\n    const base = (stepsPerFrame: number) => {\n      for (let i = 0; i < stepsPerFrame; i++) this.step(direction)\n    }\n\n    // if the moveRef is defined then record the last move\n    const withRecord = moveRef\n      ? () => {\n          base(stepsPerFrame - 1)\n          moveRef.current = this.step(direction)\n        }\n      : () => base(stepsPerFrame)\n\n    const withAnimationFrame = () => {\n      let frame: number\n      const run = () => {\n        withRecord()\n        if (this.hasStep(direction)) frame = requestAnimationFrame(run)\n        else if (onCompletion) onCompletion()\n      }\n      run()\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    }\n    const withInterval = () => {\n      const interval = setInterval(() => {\n        withRecord()\n        if (!this.hasStep(direction)) {\n          clearInterval(interval)\n          if (onCompletion) onCompletion()\n        }\n      }, 1 / (0.06 * stepsPerFrame))\n      return () => {\n        clearInterval(interval)\n      }\n    }\n\n    return stepsPerFrame >= 1 ? withAnimationFrame() : withInterval()\n  }\n\n  animateUntilCompletion(\n    timeUntilCompletion: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const stepsRemaining =\n      direction === Direction.FORWARD\n        ? this.moves.length - this.currentMove\n        : this.currentMove\n\n    // there are 0.06 frames per millisecond\n    const stepsPerFrame = stepsRemaining / (timeUntilCompletion * 0.06)\n\n    return this.animateStepsPerFrame(stepsPerFrame, direction, options)\n  }\n\n  forEachInExtra(\n    callback: (buffer: number, index: number, value: number) => void\n  ) {\n    this.bufferIds.forEach(buffer => {\n      this.buffers[buffer].forEach((value, index) =>\n        callback(buffer, index, value)\n      )\n    })\n  }\n}\n","import { MoveType, Move, Index } from './types'\nimport Untracker from './Untracker'\n\nclass BufferIdPool {\n  private _next = 1\n  private _inUse: Set<number> = new Set([])\n\n  next(): number {\n    const id = this._next++\n    this._inUse.add(id)\n    return id\n  }\n\n  free(id: number) {\n    this._inUse.delete(id)\n  }\n\n  inUse(id: number) {\n    return this._inUse.has(id)\n  }\n\n  /** Iterates over the keys in use. */\n  [Symbol.iterator]() {\n    return this._inUse[Symbol.iterator]()\n  }\n}\n\n/**\n * Abstracts the values array to the sorting algorithm so that the moves can be\n * monitored and recorded.\n */\nexport default class Tracker {\n  /** A copy of the original values that the Tracker was instantiated with. */\n  private original: number[]\n  /** A list of the current buffers in use for the sort. */\n  private buffers: {\n    /** The main values array */\n    0: number[]\n    [key: number]: number[]\n  }\n  /** An object that will give and keep track of unique keys. */\n  private bufferIdPool: BufferIdPool\n  /** The moves that have been done to the values. */\n  private moves: Move[]\n  /** The length of the values array. */\n  readonly size: number\n\n  constructor(values: number[]) {\n    this.original = [...values]\n    this.buffers = {\n      0: values\n    }\n    this.bufferIdPool = new BufferIdPool()\n    this.size = values.length\n    this.moves = []\n\n    this.swap = this.swap.bind(this)\n    this.compare = this.compare.bind(this)\n    this.malloc = this.malloc.bind(this)\n    this.memcpy = this.memcpy.bind(this)\n    this.free = this.free.bind(this)\n  }\n\n  /**\n   * Returns an untracker with the moves tracked by the tracker.\n   *\n   * @param values The array to modify while untracking\n   */\n  untrack(values = this.buffers[0]) {\n    return new Untracker(this.moves, values, this.original)\n  }\n\n  /**\n   * Swaps the values at indicies i and j.\n   */\n  swap(iIndex: Index | number, jIndex: Index | number): void {\n    // normalise the inputs\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const iBuffer = this.buffers[i.buffer]\n    const jBuffer = this.buffers[j.buffer]\n\n    iBuffer[i.index] = j.value\n    jBuffer[j.index] = i.value\n\n    this.moves.push({ type: MoveType.SWAP, i, j })\n  }\n\n  /**\n   * Compares the values at indicies i and j and returns:\n   *\n   * - **-1** If the value at i is less than the value at j;\n   * - **0** If the value at i is equal to the value at j; or,\n   * - **1** If the value at i is greater than the value at j.\n   */\n  compare(iIndex: Index | number, jIndex: Index | number) {\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const result = Math.sign(i.value - j.value)\n\n    this.moves.push({ type: MoveType.COMPARE, i, j, result })\n\n    return result\n  }\n\n  /**\n   * Comparable to the C malloc function, however instead of returning a pointer\n   * to the allocated buffer, will return an id to the buffer that was\n   * allocated.\n   */\n  malloc(size: number) {\n    const buffer = this.bufferIdPool.next()\n\n    this.buffers[buffer] = new Array(size)\n\n    this.moves.push({ type: MoveType.MALLOC, size, buffer })\n\n    return buffer\n  }\n\n  /**\n   * Copies a value from one buffer to another.\n   */\n  memcpy(from: Index | number, to: Index | number) {\n    from = this.normaliseIndex(from)\n    to = this.normaliseIndex(to)\n\n    // copy\n    const value = this.buffers[from.buffer][from.index]\n\n    // remember\n    const original = this.buffers[to.buffer][to.index]\n\n    // paste\n    this.buffers[to.buffer][to.index] = value\n\n    this.moves.push({ type: MoveType.MEMCPY, from, to, value, original })\n  }\n\n  /**\n   * Releases a chunk of memory.\n   *\n   * @param buffer The id of the buffer to free.\n   */\n  free(buffer: number) {\n    // we cant free the main values\n    if (buffer > 0) {\n      delete this.buffers[buffer]\n      this.bufferIdPool.free(buffer)\n      this.moves.push({ type: MoveType.FREE, buffer })\n    }\n  }\n\n  /**\n   * Normalises an index so that it has a buffer property. Most of the functions\n   * will work by just passing a number as the index, which should index the\n   * main values array.\n   */\n  private normaliseIndex(index: Index | number): Index & { value: number } {\n    if (typeof index === 'number') index = { buffer: 0, index }\n    const value = this.buffers[index.buffer][index.index]\n    return { ...index, value }\n  }\n}\n","import { useState, useCallback, useEffect } from 'react'\nimport unsortingAlgorithms from '../../sort/algorithms/unsort'\nimport sortingAlgorithms from '../../sort/algorithms/sort'\nimport Tracker from '../../sort/Tracker'\nimport Untracker from '../../sort/Untracker'\nimport { Direction } from '../../sort/types'\n\nconst useAlgorithms = (values: number[]) => {\n  /**\n   * The original values will be displayed on the screen.\n   *\n   * This array is intended to be modified by the unsorting algorithm so that\n   * the unsort can be untracked on the original values, and the sort can be\n   * calculated while the unsort is running.\n   */\n  const [unsortedValues, setUnsortedValues] = useState([...values])\n  useEffect(() => setUnsortedValues([...values]), [values])\n\n  const unsortWith = useCallback(\n    (name: string, block?: () => void, unblock?: () => void) => {\n      if (name === 'nothing') {\n        setUnsortedValues([...values])\n        return\n      }\n      if (!(name in unsortingAlgorithms)) return\n\n      if (block && unblock) block()\n\n      const copy = [...values]\n      const tracker = new Tracker(copy)\n\n      unsortingAlgorithms[name](tracker)\n\n      setUnsortedValues(copy)\n      const untracker = tracker.untrack(values)\n\n      untracker.animateUntilCompletion(500, Direction.FORWARD, {\n        onCompletion: () => {\n          if (unblock) unblock()\n        }\n      })\n    },\n    [values]\n  )\n\n  /** A string identifying the currently in use sort. */\n  const [sortString, setSortString] = useState('heapSort')\n\n  /** The untracker for the sort */\n  const [sortUntracker, setSortUntracker] = useState<Untracker>()\n\n  useEffect(() => {\n    let invalid = false\n\n    const calculate = async () => {\n      if (!(sortString in sortingAlgorithms)) return\n      const tracker = new Tracker(unsortedValues)\n\n      // if calculation is made async we can put an await in front of this.\n      sortingAlgorithms[sortString](tracker)\n\n      const untracker = tracker.untrack(values)\n\n      return untracker\n    }\n\n    calculate().then(untracker => !invalid && setSortUntracker(untracker))\n\n    return () => {\n      invalid = true\n    }\n  }, [sortString, unsortedValues, values])\n\n  const setSort = useCallback((name: string) => {\n    setSortString(name)\n  }, [])\n\n  return {\n    unsortWith,\n    sort: sortUntracker,\n    setSort,\n    sortString\n  }\n}\n\nexport default useAlgorithms\n","import { useState, useCallback } from 'react'\n\n/** Toggles between two values */\nfunction useToggle<T>(first: T, second: T): [T, (set?: T) => void] {\n  const [value, setValue] = useState(true)\n  const toggle = useCallback(\n    (firstOrSecond?: T) => {\n      if (firstOrSecond === first) setValue(true)\n      else if (firstOrSecond === second) setValue(false)\n      else setValue(value => !value)\n    },\n    [first, second]\n  )\n\n  return [value ? first : second, toggle]\n}\n\nexport default useToggle\n","import { useState, useCallback, useMemo } from 'react'\n\nconst useBlock = () => {\n  const [count, setCount] = useState(0)\n\n  const blocking = count > 0\n  const block = useCallback(() => {\n    setCount(count => count + 1)\n  }, [])\n\n  const unblock = useCallback(() => {\n    setCount(count => Math.max(0, count - 1))\n  }, [])\n\n  return useMemo(() => ({ blocking, block, unblock }), [\n    blocking,\n    block,\n    unblock\n  ])\n}\n\nexport default useBlock\n","import React, { useState, useEffect, useRef } from 'react'\nimport Display from './components/Display'\nimport Menu from './components/Menu'\nimport useValues from './hooks/use-values'\nimport useAlgorithms from './hooks/use-algorithms'\nimport useToggle from './hooks/use-toggle'\nimport useBlock from './hooks/use-block'\nimport sortingAlgorithms from '../sort/algorithms/sort'\nimport unsortingAlgorithms from '../sort/algorithms/unsort'\nimport { Direction, Move } from '../sort/types'\nimport './App.scss'\n\nconst App: React.FC = () => {\n  const [direction, changeDirection] = useToggle(\n    Direction.FORWARD,\n    Direction.BACKWARD\n  )\n  const [play, setPlay] = useState(false)\n  const { blocking, block, unblock } = useBlock()\n\n  /** The number of steps per frame is exponential in speed */\n  const minSpeed = -10\n  const maxSpeed = 10\n  const [speed, setSpeed] = useState(-4)\n\n  /** The length of the values array is exponantial in size */\n  const minSize = 3\n  const maxSize = 20\n  const [size, setSize] = useState(12)\n\n  const values = useValues(Math.floor(Math.pow(1.5, size)))\n\n  const { unsortWith, sort, setSort, sortString } = useAlgorithms(values)\n\n  const moveRef = useRef<Move | undefined>()\n  useEffect(() => {\n    moveRef.current = undefined\n    // Any blocking action occurring will refresh the current move.\n  }, [moveRef, blocking])\n\n  useEffect(() => {\n    if (play) {\n      return sort?.animateStepsPerFrame(Math.pow(1.3, speed), direction, {\n        onCompletion: () => {\n          setPlay(false)\n          changeDirection()\n          moveRef.current = undefined\n        },\n        moveRef\n      })\n    }\n  }, [play, sort, speed, direction, changeDirection, moveRef])\n\n  return (\n    <div className=\"App\">\n      <Menu\n        restart={{\n          disabled: blocking || !sort,\n          keyStr: 'r',\n          handler: () => {\n            changeDirection(Direction.FORWARD)\n            setPlay(false)\n            block()\n\n            sort?.animateUntilCompletion(1000, Direction.BACKWARD, {\n              onCompletion: () => unblock()\n            })\n          }\n        }}\n        speedDown={{\n          disabled: blocking || !sort,\n          // if playing leftArrow decreases speed\n          keyCode: play ? 37 : undefined,\n          handler: () => setSpeed(Math.max(minSpeed, speed - 1))\n        }}\n        stepBack={{\n          disabled: blocking || !sort,\n          // if not playing leftArrow steps back\n          keyCode: play ? undefined : 37,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.BACKWARD)\n          }\n        }}\n        play={{\n          disabled: blocking || !sort,\n          handler: () => setPlay(!play),\n          keyStr: ' ',\n          status: play\n        }}\n        reverse={{\n          disabled: blocking || !sort,\n          keyStr: '`',\n          handler: () => {\n            const oppositeDirection =\n              direction === Direction.BACKWARD\n                ? Direction.FORWARD\n                : Direction.BACKWARD\n            if (sort?.hasStep(oppositeDirection)) changeDirection()\n          },\n          status: direction === Direction.BACKWARD\n        }}\n        stepForward={{\n          disabled: blocking || !sort,\n          // if not playing rightArrow steps forward\n          keyCode: play ? undefined : 39,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.FORWARD)\n          }\n        }}\n        speedUp={{\n          disabled: blocking || !sort,\n          // if playing rightArrow increases speed\n          keyCode: play ? 39 : undefined,\n          handler: () => setSpeed(Math.min(maxSpeed, speed + 1))\n        }}\n        sizeUp={{\n          keyCode: 38,\n          handler: () => setSize(Math.min(maxSize, size + 1))\n        }}\n        sizeDown={{\n          keyCode: 40,\n          handler: () => setSize(Math.max(minSize, size - 1))\n        }}\n        unsort={{\n          disabled: blocking,\n          list: Object.keys(unsortingAlgorithms),\n          handler: algorithm => {\n            if (algorithm in unsortingAlgorithms) {\n              setPlay(false)\n              changeDirection(Direction.FORWARD)\n\n              unsortWith(algorithm, block, unblock)\n            }\n          }\n        }}\n        sort={{\n          current: sortString,\n          list: Object.keys(sortingAlgorithms),\n          handler: algorithm => {\n            if (algorithm in sortingAlgorithms && algorithm !== sortString) {\n              moveRef.current = undefined\n              unsortWith('nothing')\n              setSort(algorithm)\n            }\n          }\n        }}\n      />\n      <Display values={values} moveRef={moveRef} untracker={sort} />\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './ui/App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}