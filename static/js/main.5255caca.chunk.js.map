{"version":3,"sources":["sort/types.ts","ui/components/Display.tsx","ui/components/Button.tsx","ui/components/Menu.tsx","ui/hooks/use-values.ts","sort/Untracker.ts","sort/Tracker.ts","ui/hooks/use-algorithm.ts","ui/hooks/use-toggle.ts","sort/algorithms/tim-sort.ts","sort/algorithms/shuffle.ts","sort/algorithms/index.ts","sort/algorithms/binary-insertion-sort.ts","sort/algorithms/bubble-sort.ts","sort/algorithms/heap-sort.ts","sort/algorithms/merge-sort.ts","sort/algorithms/quick-sort.ts","sort/algorithms/shell-sort.ts","ui/App.tsx","index.tsx"],"names":["MoveType","Direction","Display","props","values","moveRef","untracker","draw","useCallback","ctx","canvas","width","height","length","setTransform","fillStyle","currentValues","forEach","value","index","fillRect","frame","drawFrame","requestAnimationFrame","i","clearRect","forEachInExtra","_buffer","save","globalAlpha","NaN","restore","move","current","type","SWAP","j","COMPARE","result","color","MEMCPY","from","to","drawMove","cancelAnimationFrame","canvasRef","useCanvas","className","ref","Button","name","handler","disabled","keyStr","keyCode","children","buttonAttributes","camelCaseName","replace","_x","y","toLowerCase","toUpperCase","useRef","useEffect","undefined","listener","e","key","click","preventDefault","window","addEventListener","removeEventListener","title","onClick","IconButton","Icon","Menu","reverse","reverseStatus","status","restart","speedDown","stepBack","play","playStatus","stepForward","speedUp","sizeUp","sizeDown","algorithm","useState","spinning","setSpinning","extra","setExtra","FaRedoAlt","style","transition","transform","onTransitionEnd","FaBackward","FaStepBackward","FaPause","FaPlay","FaSyncAlt","FaStepForward","FaForward","FaEllipsisV","list","map","camelCase","FaPlus","FaMinus","useValues","size","useMemo","push","Untracker","moves","original","buffers","bufferIds","currentMove","this","0","Set","hasNext","bind","hasPrevious","next","previous","reset","buffer","MALLOC","add","FREE","delete","id","direction","FORWARD","stepsPerFrame","options","onCompletion","base","step","withRecord","withAnimationFrame","run","hasStep","withInterval","interval","setInterval","clearInterval","timeUntilCompletion","stepsRemaining","animateStepsPerFrame","callback","Symbol","iterator","BufferIdPool","_next","_inUse","has","Tracker","bufferIdPool","swap","compare","malloc","memcpy","free","iIndex","jIndex","normaliseIndex","iBuffer","jBuffer","Math","sign","Array","useAlgorithm","resetAfter","tracker","untrack","useToggle","first","second","setValue","toggle","firstOrSecond","MergeState","pending","minGallop","shuffle","floor","random","algorithms","binaryInsertionSort","findIndex","target","low","high","mid","bubbleSort","heapSort","heapify","max","extreme","left","right","mergeSort","split","k","merge","quickSort","sort","pivot","partition","shellSort","gap","timsort","countRun","n","binarySearch","mark","shift","insertionSort","mergeLo","pA","nA","pB","nB","destination","mergeHi","mergeAt","mergeState","len","splice","ignoreAtFront","hint","lastOffset","offset","maxOffset","temp","gallopRight","gallopLeft","mergeCollapse","remaining","MIN_RUN","r","calculateMinRun","min","mergeForceCollapse","App","BACKWARD","changeDirection","setPlay","blocking","setBlocking","speed","setSpeed","setSize","pow","shuffleAlgorithm","setAlgorithm","setUntracker","a","useAlgorithmAsync","animateUntilCompletion","oppositeDirection","Object","keys","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5255caca.chunk.js","sourcesContent":["import Tracker from './Tracker'\n\n/** The type that each sorting algorithm should implement */\nexport type Algorithm = (tracker: Tracker) => void\n\n/** The different types of moves an algorithm can use */\nexport enum MoveType {\n  SWAP = 'SWAP',\n  COMPARE = 'COMPARE',\n  MALLOC = 'MALLOC',\n  MEMCPY = 'MEMCPY',\n  FREE = 'FREE'\n}\n\n/**\n * Represents an index in an allocated buffer.\n */\nexport type Index = { buffer: number; index: number }\n\nexport interface SwapMove {\n  type: MoveType.SWAP\n  i: Index & { value: number }\n  j: Index & { value: number }\n}\n\nexport interface CompareMove {\n  type: MoveType.COMPARE\n  i: Index & { value: number }\n  j: Index & { value: number }\n  result: number\n}\n\nexport interface MallocMove {\n  type: MoveType.MALLOC\n  size: number\n  buffer: number\n}\n\nexport interface MemcpyMove {\n  type: MoveType.MEMCPY\n  from: Index\n  to: Index\n  value: number\n  original: number\n}\n\nexport interface FreeMove {\n  type: MoveType.FREE\n  buffer: number\n}\n\nexport type Move = SwapMove | CompareMove | MallocMove | MemcpyMove | FreeMove\n\n/** Represents the direction of flow of an algorithm */\nexport enum Direction {\n  FORWARD = 'FORWARD',\n  BACKWARD = 'BACKWARD'\n}\n","import React, { useCallback } from 'react'\nimport useCanvas, { DrawingMethod } from 'react-hooks-use-drawing-canvas'\nimport { MoveType, Move } from '../../sort/types'\nimport Untracker from '../../sort/Untracker'\nimport './Display.scss'\n\n/** continuously displays values on the screen */\nconst Display: React.FC<{\n  values: number[]\n  moveRef: React.MutableRefObject<Move | undefined>\n  untracker?: Untracker\n}> = props => {\n  const { values, moveRef, untracker } = props\n\n  const draw = useCallback<DrawingMethod>(\n    ctx => {\n      // resize the pixels, not just a maths transform\n      ctx.canvas.width = ctx.canvas.height = values.length\n      ctx.setTransform(1, 0, 0, -1, 0, values.length)\n\n      ctx.fillStyle = 'rgb(87,163,207)'\n\n      const currentValues = [...values]\n      values.forEach((value, index) => {\n        ctx.fillRect(index, 0, 1, value)\n      })\n\n      const drawMove = () => {\n        const move = moveRef.current\n        if (!move) return\n        switch (move.type) {\n          case MoveType.SWAP:\n            {\n              const { i, j } = move\n              ctx.save()\n              ctx.fillStyle = 'cyan'\n              ctx.fillRect(i.index, 0, 1, j.value)\n              ctx.fillRect(j.index, 0, 1, i.value)\n              ctx.restore()\n\n              // We make sure that the values are repainted on the next frame by\n              // setting the current value to NaN.\n              currentValues[i.index] = currentValues[j.index] = NaN\n            }\n            break\n          case MoveType.COMPARE:\n            {\n              const { i, j, result } = move\n\n              const color = ['lime', 'orange', 'red']\n              ctx.save()\n              ctx.fillStyle = color[1 + result]\n              ctx.fillRect(i.index, 0, 1, i.value)\n\n              ctx.fillStyle = color[1 - result]\n              ctx.fillRect(j.index, 0, 1, j.value)\n              ctx.restore()\n\n              currentValues[i.index] = currentValues[j.index] = NaN\n            }\n            break\n          case MoveType.MEMCPY:\n            {\n              const { from, to, value } = move\n\n              ctx.save()\n              ctx.fillStyle = 'gold'\n              ctx.fillRect(from.index, 0, 1, value)\n              ctx.fillRect(to.index, 0, 1, value)\n              ctx.restore()\n\n              currentValues[from.index] = currentValues[to.index] = NaN\n            }\n            break\n        }\n      }\n\n      let frame: number\n      const drawFrame = () => {\n        frame = requestAnimationFrame(drawFrame)\n        // check the main values\n        for (let i = 0; i < values.length; i++) {\n          if (currentValues[i] !== values[i]) {\n            ctx.clearRect(i, 0, 1, values.length)\n            ctx.fillRect(i, 0, 1, values[i])\n            currentValues[i] = values[i]\n          }\n        }\n\n        // then the extra memory\n        untracker?.forEachInExtra((_buffer, index, value) => {\n          ctx.save()\n          ctx.globalAlpha = 0.2\n          ctx.fillStyle = 'purple'\n\n          ctx.fillRect(index, 0, 1, value)\n          // repaint the extra values each time\n          currentValues[index] = NaN\n\n          ctx.restore()\n        })\n\n        drawMove()\n      }\n\n      drawFrame()\n\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    },\n    [values, moveRef, untracker]\n  )\n\n  const canvasRef = useCanvas(draw)\n\n  return <canvas className=\"Display\" ref={canvasRef} />\n}\n\nexport default Display\n","import React, { useRef, useEffect } from 'react'\nimport { IconType } from 'react-icons/lib/cjs'\nimport './Button.scss'\n\ntype ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n  name: string\n  handler: () => void\n  disabled?: boolean\n  keyStr?: string\n  keyCode?: number\n}\n\nconst Button: React.FC<ButtonProps> = ({\n  name,\n  handler,\n  disabled,\n  keyStr,\n  keyCode,\n  children,\n  className,\n  ...buttonAttributes\n}) => {\n  const camelCaseName = name\n    .replace(/^(.)/, (_x, y) => y.toLowerCase())\n    .replace(/ (.)/g, (_x, y) => y.toUpperCase())\n\n  // We want to make it possible to specify a keyboard event that will also fire\n  // the button.\n  const ref = useRef<HTMLButtonElement>(null)\n  useEffect(() => {\n    if (keyStr !== undefined || keyCode !== undefined) {\n      const listener = (e: KeyboardEvent) => {\n        // By clicking the button instead of calling the callback, we make sure\n        // that the callback is not fired if the button is disabled\n        if (e.key === keyStr || e.keyCode === keyCode) {\n          ref.current?.click()\n          if (e.key === ' ') e.preventDefault()\n        }\n      }\n      window.addEventListener('keydown', listener)\n      return () => {\n        window.removeEventListener('keydown', listener)\n      }\n    }\n  }, [ref, keyStr, keyCode])\n\n  return (\n    <button\n      ref={ref}\n      className={`Button ${className} ${camelCaseName}`}\n      title={name}\n      onClick={handler}\n      disabled={disabled}\n      {...buttonAttributes}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport const IconButton: React.FC<ButtonProps & { Icon: IconType }> = ({\n  Icon,\n  ...props\n}) => (\n  <Button {...props} className={`${props.className} Icon`}>\n    <Icon className=\"icon\" />\n  </Button>\n)\n\nexport default Button\n","import React, { useState } from 'react'\nimport {\n  FaRedoAlt,\n  FaBackward,\n  FaStepBackward,\n  FaPlay,\n  FaSyncAlt,\n  FaForward,\n  FaStepForward,\n  FaEllipsisV,\n  FaPlus,\n  FaMinus,\n  FaPause\n} from 'react-icons/fa'\nimport Button, { IconButton } from './Button'\nimport './Menu.scss'\n\ninterface ButtonProps {\n  handler: () => void\n  keyStr?: string\n  keyCode?: number\n  disabled?: boolean\n}\n\nconst Menu: React.FC<{\n  reverse: ButtonProps & { status: boolean }\n  restart: ButtonProps\n  speedDown: ButtonProps\n  stepBack: ButtonProps\n  play: ButtonProps & { status: boolean }\n  stepForward: ButtonProps\n  speedUp: ButtonProps\n  sizeUp: ButtonProps\n  sizeDown: ButtonProps\n  algorithm: {\n    current: string\n    list: string[]\n    handler(key: string): void\n  }\n}> = ({\n  reverse: { status: reverseStatus, ...reverse },\n  restart,\n  speedDown,\n  stepBack,\n  play: { status: playStatus, ...play },\n  stepForward,\n  speedUp,\n  sizeUp,\n  sizeDown,\n  algorithm\n}) => {\n  const [spinning, setSpinning] = useState(false)\n  const [extra, setExtra] = useState(false)\n\n  return (\n    <div className=\"Menu\">\n      <IconButton\n        name=\"restart\"\n        Icon={FaRedoAlt}\n        style={\n          spinning\n            ? {\n                transition: 'transform 300ms',\n                transform: `rotate(${360}deg)`\n              }\n            : {}\n        }\n        onTransitionEnd={() => setSpinning(false)}\n        {...restart}\n        handler={() => {\n          restart.handler()\n          setSpinning(true)\n        }}\n      />\n      <IconButton name=\"speed down\" Icon={FaBackward} {...speedDown} />\n      <IconButton name=\"step back\" Icon={FaStepBackward} {...stepBack} />\n      <div className=\"playPauseWithReverse\">\n        <IconButton\n          name=\"play\"\n          Icon={playStatus ? FaPause : FaPlay}\n          style={{\n            transition: 'transform 100ms',\n            transform: `rotate(${reverseStatus ? 180 : 0}deg)`\n          }}\n          {...play}\n        />\n        <IconButton name=\"reverse\" Icon={FaSyncAlt} {...reverse} />\n      </div>\n      <IconButton name=\"step forward\" Icon={FaStepForward} {...stepForward} />\n      <IconButton name=\"speed up\" Icon={FaForward} {...speedUp} />\n      <div className={`extra ${extra ? 'show' : 'hide'}`}>\n        <IconButton\n          name=\"extra options\"\n          Icon={FaEllipsisV}\n          keyCode={27}\n          handler={() => setExtra(!extra)}\n        />\n        <div className=\"buttons\">\n          <div className=\"algorithms\">\n            {algorithm.list.map(camelCase => (\n              <Button\n                key={camelCase}\n                handler={() => {\n                  setExtra(false)\n                  algorithm.handler(camelCase)\n                }}\n                name={camelCase}\n                className={algorithm.current === camelCase ? 'active' : ''}\n              >\n                {camelCase\n                  .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                  .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n              </Button>\n            ))}\n          </div>\n          <IconButton name=\"size up\" Icon={FaPlus} {...sizeUp} />\n          <IconButton name=\"size down\" Icon={FaMinus} {...sizeDown} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default Menu\n","import { useMemo } from 'react'\n\n/**\n * Supplies an array of length `size` with evenly spaced values in (0, 1].\n *\n * The array reference will change when the size changes.\n */\nconst useValues = (size: number) => {\n  return useMemo(() => {\n    const values = []\n\n    for (let i = 1; i <= size; i++) values.push(i)\n\n    return values\n  }, [size])\n}\n\nexport default useValues\n","import { MoveType, Move, Direction } from './types'\n\n/**\n * Just as the Tracker class is for recording the algorithms. The UnTracker is\n * for replaying a tracker.\n */\nexport default class Untracker {\n  private original: number[]\n  private buffers: {\n    [key: number]: number[]\n  }\n  private bufferIds: Set<number>\n  private moves: Move[]\n  private currentMove: number\n\n  constructor(moves: Move[], values: number[], original: number[]) {\n    this.moves = moves\n    this.buffers = {\n      0: values\n    }\n    this.bufferIds = new Set()\n    this.original = original\n\n    // A tracker is not expected to undo any of the moves that were performed on\n    // the data. The untracker has to take this into account, so by default will\n    // be finished.\n    this.currentMove = this.moves.length\n\n    this.hasNext = this.hasNext.bind(this)\n    this.hasPrevious = this.hasPrevious.bind(this)\n    this.next = this.next.bind(this)\n    this.previous = this.previous.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  /** Returns true if there is a future move available to do. */\n  private hasNext() {\n    return this.currentMove < this.moves.length\n  }\n\n  /** Returns true if there is a previous move available to undo. */\n  private hasPrevious() {\n    return this.currentMove > 0\n  }\n\n  next() {\n    if (!this.hasNext()) return\n\n    const move = this.moves[this.currentMove++]\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = j.value\n          this.buffers[j.buffer][j.index] = i.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n          this.buffers[buffer] = []\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const { from, to } = move\n\n          const value = this.buffers[from.buffer][from.index]\n          this.buffers[to.buffer][to.index] = value\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  previous() {\n    if (!this.hasPrevious()) return\n\n    const move = this.moves[--this.currentMove]\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = i.value\n          this.buffers[j.buffer][j.index] = j.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const {\n            to: { buffer, index },\n            original\n          } = move\n\n          this.buffers[buffer][index] = original\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  /** Returns the values array to its original state. */\n  reset() {\n    // delete the extra buffers\n    this.bufferIds.forEach(id => {\n      delete this.buffers[id]\n    })\n\n    for (let i = 0; i < this.original.length; i++) {\n      this.buffers[0][i] = this.original[i]\n    }\n\n    this.currentMove = 0\n  }\n\n  /** Advances the untracker in a direction determined by the reverse boolean */\n  step(direction: Direction) {\n    return direction === Direction.FORWARD ? this.next() : this.previous()\n  }\n\n  /**\n   * Returns true if the untracker has a valid move available in the determined\n   * direction\n   */\n  hasStep(direction: Direction) {\n    return direction === Direction.FORWARD ? this.hasNext() : this.hasPrevious()\n  }\n\n  /**\n   * Animates the advancement of steps in a given direction.\n   *\n   * @param stepsPerFrame The number of steps to be advanced per frame\n   * @param onCompletion A callback to be run if all of the steps have been\n   * completed.\n   */\n  animateStepsPerFrame(\n    stepsPerFrame: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const { onCompletion, moveRef } = options\n\n    const base = (stepsPerFrame: number) => {\n      for (let i = 0; i < stepsPerFrame; i++) this.step(direction)\n    }\n\n    // if the moveRef is defined then record the last move\n    const withRecord = moveRef\n      ? () => {\n          base(stepsPerFrame - 1)\n          moveRef.current = this.step(direction)\n        }\n      : () => base(stepsPerFrame)\n\n    const withAnimationFrame = () => {\n      let frame: number\n      const run = () => {\n        withRecord()\n        if (this.hasStep(direction)) frame = requestAnimationFrame(run)\n        else if (onCompletion) onCompletion()\n      }\n      run()\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    }\n    const withInterval = () => {\n      const interval = setInterval(() => {\n        withRecord()\n        if (!this.hasStep(direction)) {\n          clearInterval(interval)\n          if (onCompletion) onCompletion()\n        }\n      }, 1 / (0.06 * stepsPerFrame))\n      return () => {\n        clearInterval(interval)\n      }\n    }\n\n    return stepsPerFrame >= 1 ? withAnimationFrame() : withInterval()\n  }\n\n  animateUntilCompletion(\n    timeUntilCompletion: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const stepsRemaining =\n      direction === Direction.FORWARD\n        ? this.moves.length - this.currentMove\n        : this.currentMove\n\n    // there are 0.06 frames per millisecond\n    const stepsPerFrame = stepsRemaining / (timeUntilCompletion * 0.06)\n\n    return this.animateStepsPerFrame(stepsPerFrame, direction, options)\n  }\n\n  forEachInExtra(\n    callback: (buffer: number, index: number, value: number) => void\n  ) {\n    this.bufferIds.forEach(buffer => {\n      this.buffers[buffer].forEach((value, index) =>\n        callback(buffer, index, value)\n      )\n    })\n  }\n}\n","import { MoveType, Move, Index } from './types'\nimport Untracker from './Untracker'\n\nclass BufferIdPool {\n  private _next = 1\n  private _inUse: Set<number> = new Set([])\n\n  next(): number {\n    const id = this._next++\n    this._inUse.add(id)\n    return id\n  }\n\n  free(id: number) {\n    this._inUse.delete(id)\n  }\n\n  inUse(id: number) {\n    return this._inUse.has(id)\n  }\n\n  /** Iterates over the keys in use. */\n  [Symbol.iterator]() {\n    return this._inUse[Symbol.iterator]()\n  }\n}\n\n/**\n * Abstracts the values array to the sorting algorithm so that the moves can be\n * monitored and recorded.\n */\nexport default class Tracker {\n  /** A copy of the original values that the Tracker was instantiated with. */\n  private original: number[]\n  /** A list of the current buffers in use for the sort. */\n  private buffers: {\n    /** The main values array */\n    0: number[]\n    [key: number]: number[]\n  }\n  /** An object that will give and keep track of unique keys. */\n  private bufferIdPool: BufferIdPool\n  /** The moves that have been done to the values. */\n  private moves: Move[]\n  /** The length of the values array. */\n  readonly size: number\n\n  constructor(values: number[]) {\n    this.original = [...values]\n    this.buffers = {\n      0: values\n    }\n    this.bufferIdPool = new BufferIdPool()\n    this.size = values.length\n    this.moves = []\n\n    this.swap = this.swap.bind(this)\n    this.compare = this.compare.bind(this)\n    this.malloc = this.malloc.bind(this)\n    this.memcpy = this.memcpy.bind(this)\n    this.free = this.free.bind(this)\n  }\n\n  /**\n   * Returns an untracker with the moves tracked by the tracker.\n   *\n   * @param values The array to modify while untracking\n   */\n  untrack(values = this.buffers[0]) {\n    return new Untracker(this.moves, values, this.original)\n  }\n\n  /**\n   * Swaps the values at indicies i and j.\n   */\n  swap(iIndex: Index | number, jIndex: Index | number): void {\n    // normalise the inputs\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const iBuffer = this.buffers[i.buffer]\n    const jBuffer = this.buffers[j.buffer]\n\n    iBuffer[i.index] = j.value\n    jBuffer[j.index] = i.value\n\n    this.moves.push({ type: MoveType.SWAP, i, j })\n  }\n\n  /**\n   * Compares the values at indicies i and j and returns:\n   *\n   * - **-1** If the value at i is less than the value at j;\n   * - **0** If the value at i is equal to the value at j; or,\n   * - **1** If the value at i is greater than the value at j.\n   */\n  compare(iIndex: Index | number, jIndex: Index | number) {\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const result = Math.sign(i.value - j.value)\n\n    this.moves.push({ type: MoveType.COMPARE, i, j, result })\n\n    return result\n  }\n\n  /**\n   * Comparable to the C malloc function, however instead of returning a pointer\n   * to the allocated buffer, will return an id to the buffer that was\n   * allocated.\n   */\n  malloc(size: number) {\n    const buffer = this.bufferIdPool.next()\n\n    this.buffers[buffer] = new Array(size)\n\n    this.moves.push({ type: MoveType.MALLOC, size, buffer })\n\n    return buffer\n  }\n\n  /**\n   * Copies a value from one buffer to another.\n   */\n  memcpy(from: Index | number, to: Index | number) {\n    from = this.normaliseIndex(from)\n    to = this.normaliseIndex(to)\n\n    // copy\n    const value = this.buffers[from.buffer][from.index]\n\n    // remember\n    const original = this.buffers[to.buffer][to.index]\n\n    // paste\n    this.buffers[to.buffer][to.index] = value\n\n    this.moves.push({ type: MoveType.MEMCPY, from, to, value, original })\n  }\n\n  /**\n   * Releases a chunk of memory.\n   *\n   * @param buffer The id of the buffer to free.\n   */\n  free(buffer: number) {\n    // we cant free the main values\n    if (buffer > 0) {\n      delete this.buffers[buffer]\n      this.bufferIdPool.free(buffer)\n      this.moves.push({ type: MoveType.FREE, buffer })\n    }\n  }\n\n  /**\n   * Normalises an index so that it has a buffer property. Most of the functions\n   * will work by just passing a number as the index, which should index the\n   * main values array.\n   */\n  private normaliseIndex(index: Index | number): Index & { value: number } {\n    if (typeof index === 'number') index = { buffer: 0, index }\n    const value = this.buffers[index.buffer][index.index]\n    return { ...index, value }\n  }\n}\n","import { useMemo, useState, useEffect } from 'react'\nimport { Algorithm } from '../../sort/types'\nimport Tracker from '../../sort/Tracker'\nimport Untracker from '../../sort/Untracker'\n\n/**\n * Performs an algorithm on the values via a tracker and returns the tracker\n * after the moves have been performed.\n */\nconst useAlgorithm = (\n  algorithm: Algorithm,\n  values: number[],\n  resetAfter = false\n) => {\n  return useMemo(() => {\n    const tracker = new Tracker(values)\n    algorithm(tracker)\n\n    const untracker = tracker.untrack()\n    if (resetAfter) untracker.reset()\n\n    return untracker\n  }, [algorithm, values, resetAfter])\n}\n\nexport const useAlgorithmAsync = (algorithm: Algorithm, values: number[]) => {\n  const [untracker, setUntracker] = useState<Untracker>()\n\n  useEffect(() => {\n    // async effect returns promise, hence IIFE\n    ;(async () => {\n      // calculate on a copy\n      const tracker = new Tracker([...values])\n      algorithm(tracker)\n\n      // then replay on the real values\n      const untracker = tracker.untrack(values)\n      untracker.reset()\n\n      setUntracker(untracker)\n    })()\n  }, [algorithm, values])\n\n  return untracker\n}\n\nexport default useAlgorithm\n","import { useState, useCallback } from 'react'\n\n/** Toggles between two values */\nfunction useToggle<T>(first: T, second: T): [T, (set?: T) => void] {\n  const [value, setValue] = useState(true)\n  const toggle = useCallback(\n    (firstOrSecond?: T) => {\n      if (firstOrSecond === first) setValue(true)\n      else if (firstOrSecond === second) setValue(false)\n      else setValue(value => !value)\n    },\n    [first, second]\n  )\n\n  return [value ? first : second, toggle]\n}\n\nexport default useToggle\n","import { Algorithm } from '../types'\n\ninterface Slice {\n  base: number\n  len: number\n}\n\nclass MergeState {\n  pending: Slice[] = []\n  minGallop = 7\n}\n\n/**\n * Adapted from the listsort algorithm in python\n * http://svn.python.org/projects/python/trunk/Objects/listobject.c\n */\nconst timsort: Algorithm = ({ compare, swap, malloc, memcpy, free, size }) => {\n  /**\n   * Returns the length of a run starting at a given index (up to a given\n   * index).\n   *\n   * If the run is descending the value will be the negative length of the run.\n   */\n  const countRun = (low: number, high: number) => {\n    if (low === high - 1) return 1\n    let n = low + 1\n    if (compare(low, n) < 0) {\n      while (n < high && compare(n - 1, n) > 0) n++\n      // returns negative to signify decending run\n      return low - n\n    }\n    while (n < high && compare(n - 1, n) < 0) n++\n    return n - low\n  }\n\n  /**\n   * Simmilar to binary search, except first finds a good lower and upper bound\n   * before searching.\n   */\n  const gallopLeft = (\n    mark: number,\n    from: number,\n    size: number,\n    hint: number\n  ) => {\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(base, mark) < 0) {\n      // mark should be somwhere in [hint, size]\n      const maxOffset = size - hint\n      while (offset < maxOffset && compare(base + offset, mark) < 0) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset = hint + lastOffset\n      offset = hint + offset\n    } else {\n      const maxOffset = hint\n      while (offset < maxOffset && compare(base - offset, mark) >= 0) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(from + mid, mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n    return offset\n  }\n\n  const gallopRight = (\n    mark: number,\n    from: number,\n    length: number,\n    hint: number\n  ) => {\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(base, mark) < 0) {\n      const maxOffset = size - hint\n      while (offset < maxOffset && compare(base + offset, mark) < 0) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset += hint\n      offset += hint\n    } else {\n      const maxOffset = hint\n      while (offset < maxOffset && compare(base - offset, mark) >= 0) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(from + mid, mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n\n    return offset\n  }\n\n  /**\n   * Finds the index of a value (or the index a value should be inserted at) in\n   * sorted data.\n   */\n  const binarySearch = (low: number, high: number, mark: number) => {\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n\n      if (compare(mark, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  /**\n   * Shifts values to the right, wrapping the last value to the front.\n   */\n  const shift = (low: number, high: number) => {\n    for (let i = high; i > low; i--) swap(i - 1, i)\n  }\n\n  /**\n   * Performs a binary insertion sort on a chunk.\n   */\n  const insertionSort = (low: number, high: number) => {\n    for (let i = low; i < high; i++) shift(binarySearch(low, i, i), i)\n  }\n\n  /**\n   * Reverses a chunk.\n   */\n  const reverse = (low: number, high: number) => {\n    const mid = Math.floor((high - low) / 2)\n    for (let i = 0; i < mid; i++) swap(low + i, high - i - 1)\n  }\n\n  /**\n   * Timsort's merge low method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeLo = (pA: number, nA: number, pB: number, nB: number) => {\n    // copy the A buffer into extra memory\n    const buffer = malloc(nA)\n    for (let index = 0; index < nA; index++) {\n      memcpy(pA + index, { buffer, index })\n    }\n\n    let destination = pA\n    pA = 0 // this is now the index in extra memory\n\n    while (pA < nA && nB > 0) {\n      if (compare({ buffer, index: pA }, pB) < 0) {\n        memcpy({ buffer, index: pA++ }, destination++)\n      } else {\n        memcpy(pB++, destination++)\n        nB--\n      }\n    }\n\n    while (pA < nA) memcpy({ buffer, index: pA++ }, destination++)\n\n    free(buffer)\n  }\n\n  /**\n   * Timsort's merge high method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeHi = (pA: number, nA: number, pB: number, nB: number) => {\n    // copy the B buffer into memory\n    const buffer = malloc(nB)\n    for (let index = 0; index < nB; index++) {\n      memcpy(pB + index, { buffer, index })\n    }\n\n    let destination = pB + nB\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: nB - 1 }, pA + nA - 1) > 0) {\n        memcpy({ buffer, index: --nB }, --destination)\n      } else {\n        memcpy(pA + --nA, --destination)\n      }\n    }\n    while (nB > 0) memcpy({ buffer, index: --nB }, --destination)\n\n    free(buffer)\n  }\n\n  /** Merges two slices */\n  const mergeAt = (mergeState: MergeState, i: number) => {\n    const { pending } = mergeState\n    let pA = pending[i].base\n    let nA = pending[i].len\n    const pB = pending[i + 1].base\n    let nB = pending[i + 1].len\n\n    // record the length of the combined runs.\n    pending[i].len = nA + nB\n    // remove the chunk that will be merged.\n    pending.splice(i + 1, 1)\n\n    // Where does b start in a? Elements before that can be ignored.\n    const ignoreAtFront = gallopRight(pB, pA, nA, 0)\n    pA += ignoreAtFront\n    nA -= ignoreAtFront\n\n    nB = gallopLeft(pA + nA - 1, pB, nB, nB - 1)\n\n    const merge = nA <= nB ? mergeHi : mergeLo\n    merge(pA, nA, pB, nB)\n  }\n\n  const mergeCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len <= pending[n].len + pending[n + 1].len) {\n        if (pending[n - 1].len < pending[n + 1].len) n -= 1\n        mergeAt(mergeState, n)\n      } else if (pending[n].len <= pending[n + 1].len) {\n        mergeAt(mergeState, n)\n      } else break\n    }\n  }\n\n  const mergeForceCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len < pending[n + 1].len) n -= 1\n      mergeAt(mergeState, n)\n    }\n  }\n\n  /** Calculates the optimal minimum length of a run. */\n  const calculateMinRun = (length: number) => {\n    let r = 0 // becomes 1 if any 1 bits are shifted off.\n\n    while (length >= 64) {\n      r |= length & 1\n      length >>= 1\n    }\n\n    return length + r\n  }\n\n  const mergeState = new MergeState()\n  let remaining = size\n  let low = 0\n\n  const MIN_RUN = calculateMinRun(size)\n  while (remaining > 0) {\n    let n = countRun(low, size)\n\n    // reverse if descending\n    if (n < 0) {\n      n *= -1\n      reverse(low, low + n)\n    }\n\n    // exdend if too short\n    if (n < MIN_RUN) {\n      n = Math.min(MIN_RUN, remaining)\n      insertionSort(low, low + n)\n    }\n\n    // push run onto pending stack and maybe merge\n    mergeState.pending.push({\n      base: low,\n      len: n\n    })\n    mergeCollapse(mergeState)\n\n    low += n\n    remaining -= n\n  }\n  mergeForceCollapse(mergeState)\n}\n\nexport default timsort\n","import { Algorithm } from '../types'\n\n/**\n * This algorithm does not sort an array - it shuffles an array. The original\n * values will be created sorted; this algorithm will then *un-sort* the values\n * before one of the actual algorithms can sort it.\n */\nconst shuffle: Algorithm = ({ swap, size }) => {\n  for (let i = 0; i < size; i++) {\n    const j = i + Math.floor(Math.random() * (size - i))\n    swap(i, j)\n  }\n}\n\nexport default shuffle\n","import { Algorithm } from '../types'\nimport binaryInsertionSort from './binary-insertion-sort'\nimport bubbleSort from './bubble-sort'\nimport heapSort from './heap-sort'\nimport mergeSort from './merge-sort'\nimport quickSort from './quick-sort'\nimport shellSort from './shell-sort'\nimport timsort from './tim-sort'\n\nimport shuffle from './shuffle'\n\nconst algorithms: { [key: string]: Algorithm } = {\n  binaryInsertionSort,\n  bubbleSort,\n  heapSort,\n  mergeSort,\n  quickSort,\n  shellSort,\n  timsort\n}\n\nexport { shuffle }\n\nexport default algorithms\n","import { Algorithm } from '../types'\n\nconst binaryInsertionSort: Algorithm = ({ compare, swap, size }) => {\n  const findIndex = (target: number) => {\n    let low = 0\n    let high = target\n\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n      if (compare(target, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  for (let i = 1; i < size; i++) {\n    const index = findIndex(i)\n    for (let j = i; j > index; j--) {\n      swap(j, j - 1)\n    }\n  }\n}\n\nexport default binaryInsertionSort\n","import { Algorithm } from '../types'\n\n/**\n * Bubble sort is a sorting algorithm that will sort an array of n comparable\n * elements.\n *\n * Bubble sort works by checking adjacent values. If the right value is less\n * than the left value, it swaps them. Otherwise it leaves them alone.\n *\n * After one pass of the entire array from the end to the beginning, the\n * smallest element in the array will be at the front. Then the pairs are all\n * checked again (but not the definitely sorted part).\n *\n * Since we only have one element sorted each pass, we will have to make a pass\n * for each (next smallest) element in the array, leading to a 'sum of the\n * numbers up to n' style time complexity, which is O(n^2).\n *\n * The space complexity however is very simple, we only keep track of the number\n * of definitely sorted values and our position in the current pass. This means\n * we have O(1) space complexity.\n * @param tracker\n */\nconst bubbleSort: Algorithm = ({ swap, compare, size }) => {\n  for (let i = 0; i < size - 1; i++) {\n    for (let j = size - 1; j > i; j--) {\n      if (compare(j, j - 1) < 0) swap(j, j - 1)\n    }\n  }\n}\n\nexport default bubbleSort\n","import { Algorithm } from '../types'\n\nconst heapSort: Algorithm = ({ compare, swap, size }) => {\n  const heapify = (current: number, max: number) => {\n    let extreme, left, right\n\n    while (current < max) {\n      extreme = current\n      left = 2 * current + 1\n      right = 2 * current + 2\n\n      if (left < max && compare(extreme, left) < 0) extreme = left\n      if (right < max && compare(extreme, right) < 0) extreme = right\n\n      if (extreme === current) return\n      swap(current, extreme)\n      current = extreme\n    }\n  }\n\n  for (let i = 0; i < size; i++) heapify(size - i - 1, size)\n\n  for (let i = 0; i < size; i++) {\n    swap(0, size - i - 1)\n    heapify(0, size - i - 1)\n  }\n}\n\nexport default heapSort\n","import { Algorithm } from '../types'\n\nconst mergeSort: Algorithm = ({ compare, malloc, memcpy, free, size }) => {\n  const merge = (low: number, mid: number, high: number) => {\n    const buffer = malloc(high - low)\n\n    let index = 0\n    let i = low\n    let j = mid\n    while (i < mid && j < high) {\n      if (compare(i, j) < 0) memcpy(i++, { buffer, index })\n      else memcpy(j++, { buffer, index })\n      index += 1\n    }\n    // copy remaining values to the end\n    if (i < mid) {\n      for (let k = i; k < mid; k++) {\n        memcpy(k, high - mid + k)\n      }\n    }\n    // copy back from memory\n    while (index--) {\n      memcpy({ buffer, index }, low + index)\n    }\n\n    free(buffer)\n  }\n\n  const split = (low: number, high: number) => {\n    const mid = low + Math.floor((high - low) / 2)\n\n    if (low < mid) {\n      split(low, mid)\n      split(mid, high)\n      merge(low, mid, high)\n    }\n  }\n  split(0, size)\n}\n\nexport default mergeSort\n","import { Algorithm } from '../types'\n\n/**\n * Quick sort is a recursive sorting algorithm that will sort an array of `n`\n * comparable elements.\n *\n * Quick sort works on subarrays:\n * - It chooses a \"pivot\", any single element in the subarray. The pivot can be\n *   chosen arbitrarily, but difference choices will lead to different runtimes\n *   on different data.\n * - It then partitions the subarray into three portions:\n *   - A subarray of the elements less than or equal to than the pivot;\n *   - The pivot; and,\n *   - A subarray of the elements larger than the pivot.\n * - Then it runs the algorithm again on the two subarrays.\n *\n * Since the subarrays are smaller, the depth will be at most the length of the\n * array (if the smallest value in the array is the first element in every\n * subarray; the array was sorted already) and the sort will finish. Giving us a\n * worst case of O(n^2) time complexity.\n *\n * On average for random data however the split will be closer to the middle and\n * in the best case we will have half the values in each part. Thus in our best\n * case we will have O(n log(n)) time complexity.\n *\n * Since we are recursing, we will have O(1) space for each layer in the\n * recursion, so the worst case for our space complexity will be O(n).\n *\n * In the best case however we will have less layers alive at any one time,\n * meaning our space complexity would be O(log(n)).\n */\nconst quickSort: Algorithm = ({ swap, compare, size }) => {\n  const partition = (low: number, high: number) => {\n    const pivot = low\n\n    let i = high\n    for (let j = high; j > pivot; j--) {\n      if (compare(pivot, j) < 0) swap(j, i--)\n    }\n\n    swap(pivot, i)\n    return i\n  }\n\n  const sort = (low: number, high: number) => {\n    if (low < high) {\n      const mid = partition(low, high)\n      sort(low, mid - 1)\n      sort(mid + 1, high)\n    }\n  }\n\n  sort(0, size - 1)\n}\n\nexport default quickSort\n","import { Algorithm } from '../types'\n\nconst shellSort: Algorithm = ({ compare, swap, size }) => {\n  let gap = ~~(size / 2)\n\n  while (gap > 0) {\n    for (let i = gap; i < size; i++) {\n      for (let j = i; j >= gap && compare(j - gap, j) > 0; j -= gap) {\n        swap(j - gap, j)\n      }\n    }\n    gap = ~~(gap / 2)\n  }\n}\n\nexport default shellSort\n","import React, { useState, useEffect, useRef } from 'react'\nimport Display from './components/Display'\nimport Menu from './components/Menu'\nimport useValues from './hooks/use-values'\nimport useAlgorithm, { useAlgorithmAsync } from './hooks/use-algorithm'\nimport useToggle from './hooks/use-toggle'\nimport algorithms, { shuffle as shuffleAlgorithm } from '../sort/algorithms'\nimport { Direction, Move } from '../sort/types'\nimport './App.scss'\n\nconst App: React.FC = () => {\n  const [direction, changeDirection] = useToggle(\n    Direction.FORWARD,\n    Direction.BACKWARD\n  )\n  const [play, setPlay] = useState(false)\n  const [blocking, setBlocking] = useState(false)\n\n  /** The number of steps per frame is exponential in speed */\n  const minSpeed = -10\n  const maxSpeed = 10\n  const [speed, setSpeed] = useState(-4)\n\n  /** The length of the values array is exponantial in size */\n  const minSize = 3\n  const maxSize = 20\n  const [size, setSize] = useState(12)\n\n  const values = useValues(Math.floor(Math.pow(1.5, size)))\n\n  const shuffle = useAlgorithm(shuffleAlgorithm, values)\n\n  const [algorithm, setAlgorithm] = useState('timsort')\n  const sort = useAlgorithmAsync(algorithms[algorithm], values)\n\n  const moveRef = useRef<Move | undefined>()\n  useEffect(() => {\n    moveRef.current = undefined\n    // Any blocking action occurring will refresh the current move.\n  }, [moveRef, blocking])\n\n  useEffect(() => {\n    setBlocking(true)\n    setPlay(false)\n    changeDirection(Direction.FORWARD)\n    shuffle.reset()\n    return shuffle.animateUntilCompletion(2000, Direction.FORWARD, {\n      onCompletion: () => {\n        setBlocking(false)\n      }\n    })\n  }, [shuffle, changeDirection])\n\n  useEffect(() => {\n    if (play) {\n      return sort?.animateStepsPerFrame(Math.pow(1.3, speed), direction, {\n        onCompletion: () => {\n          setPlay(false)\n          changeDirection()\n          moveRef.current = undefined\n        },\n        moveRef\n      })\n    }\n  }, [play, sort, speed, direction, changeDirection, moveRef])\n\n  return (\n    <div className=\"App\">\n      <Menu\n        restart={{\n          disabled: blocking,\n          keyStr: 'r',\n          handler: () => {\n            changeDirection(Direction.FORWARD)\n            setPlay(false)\n            setBlocking(true)\n\n            sort?.animateUntilCompletion(1000, Direction.BACKWARD, {\n              onCompletion: () => setBlocking(false)\n            })\n          }\n        }}\n        speedDown={{\n          disabled: blocking,\n          // if playing leftArrow decreases speed\n          keyCode: play ? 37 : undefined,\n          handler: () => setSpeed(Math.max(minSpeed, speed - 1))\n        }}\n        stepBack={{\n          disabled: blocking,\n          // if not playing leftArrow steps back\n          keyCode: play ? undefined : 37,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.BACKWARD)\n          }\n        }}\n        play={{\n          disabled: blocking,\n          handler: () => setPlay(!play),\n          keyStr: ' ',\n          status: play\n        }}\n        reverse={{\n          disabled: blocking,\n          keyStr: '`',\n          handler: () => {\n            const oppositeDirection =\n              direction === Direction.BACKWARD\n                ? Direction.FORWARD\n                : Direction.BACKWARD\n            if (sort?.hasStep(oppositeDirection)) changeDirection()\n          },\n          status: direction === Direction.BACKWARD\n        }}\n        stepForward={{\n          disabled: blocking,\n          // if not playing rightArrow steps forward\n          keyCode: play ? undefined : 39,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.FORWARD)\n          }\n        }}\n        speedUp={{\n          disabled: blocking,\n          // if playing rightArrow increases speed\n          keyCode: play ? 39 : undefined,\n          handler: () => setSpeed(Math.min(maxSpeed, speed + 1))\n        }}\n        sizeUp={{\n          keyCode: 38,\n          handler: () => setSize(Math.min(maxSize, size + 1))\n        }}\n        sizeDown={{\n          keyCode: 40,\n          handler: () => setSize(Math.max(minSize, size - 1))\n        }}\n        algorithm={{\n          current: algorithm,\n          list: Object.keys(algorithms),\n          handler: algorithm => {\n            if (algorithm in algorithms) {\n              if (sort) {\n                setBlocking(true)\n                changeDirection(Direction.FORWARD)\n                setPlay(false)\n\n                const onCompletion = () => {\n                  setAlgorithm(algorithm)\n                  setBlocking(false)\n                  setPlay(true)\n                }\n\n                if (sort.hasStep(Direction.FORWARD)) {\n                  sort.animateUntilCompletion(500, Direction.BACKWARD, {\n                    onCompletion\n                  })\n                } else {\n                  // the sort has finished, just run the shuffle again\n                  shuffle.reset()\n                  shuffle.animateUntilCompletion(500, Direction.FORWARD, {\n                    onCompletion\n                  })\n                }\n              } else {\n                setAlgorithm(algorithm)\n              }\n            }\n          }\n        }}\n      />\n      <Display values={values} moveRef={moveRef} untracker={sort} />\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './ui/App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}