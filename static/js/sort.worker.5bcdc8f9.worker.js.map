{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../src/comlink.ts","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","sort/algorithms/sort/binary-insertion-sort.ts","sort/algorithms/sort/introsort.ts","sort/types.ts","sort/algorithms/sort/tim-sort.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","sort/algorithms/sort/index.ts","sort/algorithms/sort/bubble-sort.ts","sort/algorithms/sort/heap-sort.ts","sort/algorithms/sort/merge-sort.ts","sort/algorithms/sort/quick-sort.ts","sort/algorithms/sort/radix-sort-lsb.ts","sort/algorithms/sort/radix-sort-msb.ts","sort/algorithms/sort/shell-sort.ts","sort/algorithms/unsort/common.ts","sort/algorithms/unsort/index.ts","sort/algorithms/unsort/cut.ts","sort/algorithms/unsort/hindu-shuffle.ts","sort/algorithms/unsort/overhand-shuffle.ts","sort/algorithms/unsort/perfect-riffle-shuffle.ts","sort/algorithms/unsort/randomise.ts","sort/algorithms/unsort/reverse.ts","sort/algorithms/unsort/riffle-shuffle.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","sort/TransferableMovesList.ts","sort/Tracker.ts","sort/sort.worker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_arrayLikeToArray","arr","len","length","arr2","Array","_unsupportedIterableToArray","minLen","toString","slice","constructor","from","test","_slicedToArray","isArray","iterator","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","err","TypeError","_defineProperty","obj","configurable","writable","_setPrototypeOf","setPrototypeOf","__proto__","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","e","Parent","args","Class","a","apply","instance","Function","arguments","_toConsumableArray","iter","proxyMarker","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","MessageChannel","port1","port2","expose","deserialize","port","start","createProxy","ep","path","target","isProxyReleased","proxy","_target","prop","throwIfProxyReleased","requestResponseMessage","type","map","then","closeEndPoint","fromWireValue","set","rawValue","toWireValue","transferables","_thisArg","rawArgumentList","last","processArguments","argumentList","Error","isError","message","stack","serialized","assign","self","addEventListener","callback","ev","data","returnValue","id","parent","reduce","transfer","Promise","resolve","catch","wireValue","postMessage","removeEventListener","endpoint","isMessagePort","close","isReleased","processed","v","concat","transferCache","WeakMap","transfers","allowArrayLike","it","F","f","normalCompletion","didErr","step","_e2","handler","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","introSort","compare","swap","size","HEAP_SORT_THRESHOLD","log2","bisect","lo","hi","mid","heapify","base","root","max","left","right","extreme","quickSort","depth","j","k","insertionSort","heapSort","pivot","candidates","sort","findPivot","MoveType","Direction","MergeState","Constructor","pending","minGallop","algorithms","binaryInsertionSort","findIndex","low","high","index","bubbleSort","current","introsort","mergeSort","malloc","memcpy","free","split","buffer","merge","partition","radixSortLsb","nthBitSet","needle","zeroIndex","oneIndex","radixSortMsb","loStack","hiStack","needleStack","pop","zero","one","shellSort","gap","timsort","countRun","gallopLeft","mark","hint","fromBuffer","indexFrom","lastOffset","offset","maxOffset","temp","gallopRight","binarySearch","shift","reverse","mergeLo","mergeState","pA","nA","pB","nB","destination","countA","countB","gallop","mergeHi","mergeAt","splice","ignoreAtFront","mergeCollapse","remaining","MIN_RUN","calculateMinRun","min","mergeForceCollapse","randomNormal","mean","stddev","u","normal","sqrt","log","cos","PI","boundAndRound","round","cut","hinduShuffle","group","overhandShuffle","perfectRiffleShuffle","halfSize","firstHalf","secondHalf","randomise","riffleShuffle","dest","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","TransferableMovesBuilder","this","ArrayBuffer","byteLength","newBuffer","oldView","DataView","newView","setUint8","getUint8","move","growIfNeeded","idx","view","COMPARE","setUint32","setInt8","result","SWAP","MALLOC","MEMCPY","to","original","FREE","NTH_BIT_SET","encodeMove","BufferIdPool","_next","_inUse","Set","add","delete","has","Tracker","values","buffers","bufferIdPool","moves","0","iIndex","jIndex","normaliseIndex","iBuffer","jBuffer","addMove","sign","givenIndex","Boolean","Comlink","sorts","unsorts","console","tracker","getMoves","numMoves"],"mappings":"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","file":"static/js/sort.worker.5bcdc8f9.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/sorting-visualiser/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"./setPrototypeOf\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \\_()_/\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didnt happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer(obj: any, transfers: Transferable[]) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import { Algorithm } from '../../types'\n\nconst binaryInsertionSort: Algorithm = ({ compare, swap, size }) => {\n  const findIndex = (target: number) => {\n    let low = 0\n    let high = target\n\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n      if (compare(target, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  for (let i = 1; i < size; i++) {\n    const index = findIndex(i)\n    for (let j = i; j > index; j--) {\n      swap(j, j - 1)\n    }\n  }\n}\n\nexport default binaryInsertionSort\n","import { Algorithm } from '../../types'\n\n/**\n * Introsort is a hybrid sorting algorithm developed for the C++ standard\n * library by David Musser.\n *\n * It starts with quick sort, and then switches to heap sort (if the recursion\n * depth exceeds some bound), or insertion sort (if the partition size is less\n * than some bound).\n */\nconst introSort: Algorithm = ({ compare, swap, size }) => {\n  const INSERTION_SORT_THRESHOLD = 16\n\n  // It is more likely that introsort will avoid heap sort for longer, but for\n  // the sizes of array in this application, the depth will never reach that\n  // point, and the user will not experience the heap sort part of the\n  // algorithm.\n  const HEAP_SORT_THRESHOLD = Math.floor((Math.log2(size) * 3) / 4)\n\n  /**\n   * Does a binary search on the subarray [lo:hi] for insertion point of the\n   * target value (passed as an index).\n   */\n  const bisect = (lo: number, hi: number, target: number) => {\n    while (lo < hi) {\n      const mid = lo + ((hi - lo) >> 1)\n      if (compare(mid, target) < 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    return lo\n  }\n\n  /**\n   * Sorts the subarray [lo:hi] with insertion sort.\n   */\n  const insertionSort = (lo: number, hi: number) => {\n    for (let i = 1; i < hi - lo; i++) {\n      // Find where the next unsorted element should go.\n      const j = bisect(lo, lo + i, lo + i)\n\n      // Swap elements to bubble it down to where it should be.\n      for (let k = lo + i; k > j; k--) {\n        swap(k, k - 1)\n      }\n    }\n  }\n\n  /**\n   * Bubbles the value in the heap down to retain heap substructure.\n   */\n  const heapify = (base: number, root: number, max: number) => {\n    while (true) {\n      const left = 2 * root + 1\n      const right = 2 * root + 2\n      let extreme = root\n\n      if (left < max && compare(base + extreme, base + left) < 0) {\n        extreme = left\n      }\n\n      if (right < max && compare(base + extreme, base + right) < 0) {\n        extreme = right\n      }\n\n      if (extreme === root) {\n        return\n      }\n\n      swap(base + root, base + extreme)\n      root = extreme\n    }\n  }\n\n  /**\n   * Sorts the subarray [lo:hi] with heapsort.\n   */\n  const heapSort = (lo: number, hi: number) => {\n    let n = hi - lo\n\n    // Heapify the subarray\n    for (let i = n - 1; i >= 0; i--) {\n      heapify(lo, i, n)\n    }\n\n    while (n > 1) {\n      swap(lo, lo + n - 1)\n      heapify(lo, 0, n - 1)\n      n -= 1\n    }\n  }\n\n  // Chooses a pivot in the partition from lo to hi by selecting three random\n  // elements and taking their median.\n  const findPivot = (lo: number, hi: number) => {\n    const n = 3\n    const candidates = Array(3)\n      .fill(0)\n      .map(() => lo + Math.floor(Math.random() * (hi - lo)))\n\n    candidates.sort((i, j) => compare(i, j))\n    return candidates[n >> 1]\n  }\n\n  const quickSort = (lo: number, hi: number, depth: number) => {\n    if (hi - lo < INSERTION_SORT_THRESHOLD) {\n      insertionSort(lo, hi)\n      return\n    }\n    if (depth > HEAP_SORT_THRESHOLD) {\n      heapSort(lo, hi)\n      return\n    }\n\n    const pivot = findPivot(lo, hi)\n    swap(pivot, lo)\n\n    // Now we partition the subarray.\n    let left = lo + 1\n    let right = hi - 1\n\n    while (left < right) {\n      while (left < right && compare(left, lo) <= 0) {\n        left += 1\n      }\n      while (left < right && compare(lo, right) < 0) {\n        right -= 1\n      }\n      swap(left, right)\n    }\n\n    // Left may point to the last element in the left half or the first element\n    // in the second half.\n    if (compare(lo, left) < 0) {\n      left -= 1\n    }\n\n    swap(lo, left)\n    // we now have two new sections:\n    // - [lo:left] which contains all elements less than or equal to the pivot.\n    // - [left:hi] which contains all elements more than the pivot.\n\n    quickSort(lo, left + 1, depth + 1)\n    quickSort(left + 1, hi, depth + 1)\n  }\n\n  quickSort(0, size, 1)\n}\n\nexport default introSort\n","import Tracker from './Tracker'\nimport Untracker from './Untracker'\n\n/** The type that each sorting algorithm should implement */\nexport type Algorithm = (tracker: Tracker) => void\n\n/** The different types of moves an algorithm can use */\nexport enum MoveType {\n  SWAP = 1,\n  COMPARE = 2,\n  MALLOC = 3,\n  MEMCPY = 4,\n  FREE = 5,\n  NTH_BIT_SET = 6\n}\n\n/**\n * Represents an index in an allocated buffer.\n */\nexport type Index = { buffer: number; index: number }\n\nexport interface SwapMove {\n  type: MoveType.SWAP\n  i: Index & { value: number }\n  j: Index & { value: number }\n}\n\nexport interface CompareMove {\n  type: MoveType.COMPARE\n  i: Index & { value: number }\n  j: Index & { value: number }\n  result: number\n}\n\nexport interface MallocMove {\n  type: MoveType.MALLOC\n  size: number\n  buffer: number\n}\n\nexport interface MemcpyMove {\n  type: MoveType.MEMCPY\n  from: Index\n  to: Index\n  value: number\n  original: number\n}\n\nexport interface FreeMove {\n  type: MoveType.FREE\n  buffer: number\n}\n\nexport interface NthBitSetMove {\n  type: MoveType.NTH_BIT_SET\n  index: Index\n  result: boolean\n}\n\nexport type Move =\n  | SwapMove\n  | CompareMove\n  | MallocMove\n  | MemcpyMove\n  | FreeMove\n  | NthBitSetMove\n\n/** Represents the direction of flow of an algorithm */\nexport enum Direction {\n  FORWARD = 'FORWARD',\n  BACKWARD = 'BACKWARD'\n}\n\n/**\n * The signature for the worker's calculate method.\n *\n * The return value will consist of the array buffer representing the moves, the\n * number of encoded moves in the array buffer, and the final state of the\n * values array.\n */\nexport type WorkerCalculateMethod = (\n  type: 'sort' | 'unsort',\n  name: string,\n  values: number[]\n) => [ArrayBuffer, number, number[]]\n\n/**\n * The signature for the main thread's calculate method, wrapping the worker.\n */\nexport type MainThreadCalculateMethod = (\n  type: 'sort' | 'unsort',\n  name: string,\n  valuesToSort: number[],\n  valuesToTrack: number[]\n) => Promise<[Untracker, number[]]>\n","import { Algorithm, Index } from '../../types'\n\ninterface Slice {\n  base: number\n  len: number\n}\n\nclass MergeState {\n  pending: Slice[] = []\n  minGallop = 7\n}\n\n/**\n * Adapted from the listsort algorithm in python\n * http://svn.python.org/projects/python/trunk/Objects/listobject.c\n */\nconst timsort: Algorithm = ({ compare, swap, malloc, memcpy, free, size }) => {\n  /**\n   * Returns the length of a run starting at a given index (up to a given\n   * index).\n   *\n   * If the run is descending the value will be the negative length of the run.\n   */\n  const countRun = (low: number, high: number) => {\n    if (low === high - 1) return 1\n    let n = low + 1\n    if (compare(low, n) > 0) {\n      while (n < high && compare(n - 1, n) > 0) n++\n      // returns negative to signify decending run\n      return low - n\n    }\n    while (n < high && compare(n - 1, n) <= 0) n++\n    return n - low\n  }\n\n  /**\n   * Simmilar to binary search, except first finds a good lower and upper bound\n   * before searching.\n   */\n  const gallopLeft = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      // mark should be somwhere in [hint, size]\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset = hint + lastOffset\n      offset = hint + offset\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n    return offset\n  }\n\n  const gallopRight = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    /** optionally set the buffer that from should access */\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset += hint\n      offset += hint\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n\n    return offset\n  }\n\n  /**\n   * Finds the index of a value (or the index a value should be inserted at) in\n   * sorted data.\n   */\n  const binarySearch = (low: number, high: number, mark: number) => {\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n\n      if (compare(mark, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  /**\n   * Shifts values to the right, wrapping the last value to the front.\n   */\n  const shift = (low: number, high: number) => {\n    for (let i = high; i > low; i--) swap(i - 1, i)\n  }\n\n  /**\n   * Performs a binary insertion sort on a chunk.\n   */\n  const insertionSort = (low: number, high: number) => {\n    for (let i = low; i < high; i++) shift(binarySearch(low, i, i), i)\n  }\n\n  /**\n   * Reverses a chunk.\n   */\n  const reverse = (low: number, high: number) => {\n    const mid = Math.floor((high - low) / 2)\n    for (let i = 0; i < mid; i++) swap(low + i, high - i - 1)\n  }\n\n  /**\n   * Timsort's merge low method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeLo = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the A buffer into extra memory\n    const buffer = malloc(nA)\n    for (let index = 0; index < nA; index++) {\n      memcpy(pA + index, { buffer, index })\n    }\n\n    let destination = pA\n    pA = 0 // this is now the index in extra memory\n    let countA = 0\n    let countB = 0\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n\n        countA = gallopRight(pB, pA, nA, 0, buffer)\n        for (let i = 0; i < countA; i++) {\n          memcpy({ buffer, index: pA++ }, destination++)\n        }\n        nA -= countA\n        // if (nA === 0) return\n\n        countB = gallopLeft({ buffer, index: pA }, pB, nB, 0)\n        for (let i = 0; i < countB; i++) {\n          memcpy(pB++, destination++)\n        }\n        nB -= countB\n        // if (nB === 0) return\n      }\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: pA }, pB) < 0) {\n        memcpy({ buffer, index: pA++ }, destination++)\n        nA -= 1\n        countA += 1\n        countB = 0\n      } else {\n        memcpy(pB++, destination++)\n        nB -= 1\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n\n    while (nA-- > 0) memcpy({ buffer, index: pA++ }, destination++)\n\n    free(buffer)\n  }\n\n  /**\n   * Timsort's merge high method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeHi = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the B buffer into memory\n    const buffer = malloc(nB)\n    for (let index = 0; index < nB; index++) {\n      memcpy(pB + index, { buffer, index })\n    }\n\n    let destination = pB + nB\n    let countA = 0 // number of times A won in a row\n    let countB = 0 // number of times B won in a row\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n        countA = nA - gallopRight({ buffer, index: nB - 1 }, pA, nA, nA - 1)\n        for (let i = 0; i < countA; i++) {\n          memcpy(pA + --nA, --destination)\n        }\n        // if (nA === 0) return\n\n        countB = nB - gallopLeft(pA + nA - 1, 0, nB, nB - 1, buffer)\n        for (let i = 0; i < countB; i++) {\n          memcpy({ buffer, index: --nB }, --destination)\n        }\n        // if (nB === 0) return\n      }\n      // punishment for not gallopping anymore\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: nB - 1 }, pA + nA - 1) <= 0) {\n        memcpy(pA + --nA, --destination)\n        countA += 1\n        countB = 0\n      } else {\n        memcpy({ buffer, index: --nB }, --destination)\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n    while (nB > 0) memcpy({ buffer, index: --nB }, --destination)\n\n    free(buffer)\n  }\n\n  /** Merges two slices */\n  const mergeAt = (mergeState: MergeState, i: number) => {\n    const { pending } = mergeState\n    let pA = pending[i].base\n    let nA = pending[i].len\n    const pB = pending[i + 1].base\n    let nB = pending[i + 1].len\n\n    // record the length of the combined runs.\n    pending[i].len = nA + nB\n    // remove the chunk that will be merged.\n    pending.splice(i + 1, 1)\n\n    // Where does b start in a? Elements before that can be ignored.\n    const ignoreAtFront = gallopRight(pB, pA, nA, 0)\n    pA += ignoreAtFront\n    nA -= ignoreAtFront\n\n    nB = gallopLeft(pA + nA - 1, pB, nB, nB - 1)\n\n    const merge = nA <= nB ? mergeLo : mergeHi\n    merge(mergeState, pA, nA, pB, nB)\n  }\n\n  const mergeCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len <= pending[n].len + pending[n + 1].len) {\n        if (pending[n - 1].len < pending[n + 1].len) n -= 1\n        mergeAt(mergeState, n)\n      } else if (pending[n].len <= pending[n + 1].len) {\n        mergeAt(mergeState, n)\n      } else break\n    }\n  }\n\n  const mergeForceCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len < pending[n + 1].len) n -= 1\n      mergeAt(mergeState, n)\n    }\n  }\n\n  /** Calculates the optimal minimum length of a run. */\n  const calculateMinRun = (length: number) => {\n    let r = 0 // becomes 1 if any 1 bits are shifted off.\n\n    // The true version of timsort uses 64 as a max, min size, we will use 16 so\n    // that the merging can be seen at smaller sizes\n    // while (length >= 64) {\n    while (length >= 16) {\n      r |= length & 1\n      length >>= 1\n    }\n\n    return length + r\n  }\n\n  const mergeState = new MergeState()\n  let remaining = size\n  let low = 0\n\n  const MIN_RUN = calculateMinRun(size)\n  while (remaining > 0) {\n    let n = countRun(low, size)\n\n    // reverse if descending\n    if (n < 0) {\n      n *= -1\n      reverse(low, low + n)\n    }\n\n    // exdend if too short\n    if (n < MIN_RUN) {\n      n = Math.min(MIN_RUN, remaining)\n      insertionSort(low, low + n)\n    }\n\n    // push run onto pending stack and maybe merge\n    mergeState.pending.push({\n      base: low,\n      len: n\n    })\n    mergeCollapse(mergeState)\n\n    low += n\n    remaining -= n\n  }\n  mergeForceCollapse(mergeState)\n}\n\nexport default timsort\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import { Algorithm } from '../../types'\nimport binaryInsertionSort from './binary-insertion-sort'\nimport bubbleSort from './bubble-sort'\nimport heapSort from './heap-sort'\nimport introsort from './introsort'\nimport mergeSort from './merge-sort'\n// import pancakeSort from './pancake-sort'\nimport quickSort from './quick-sort'\nimport radixSortLsb from './radix-sort-lsb'\nimport radixSortMsb from './radix-sort-msb'\nimport shellSort from './shell-sort'\nimport timsort from './tim-sort'\n\nexport const algorithms: { [key: string]: Algorithm } = {\n  binaryInsertionSort,\n  bubbleSort,\n  heapSort,\n  introsort,\n  mergeSort,\n  // pancakeSort,\n  quickSort,\n  radixSortLsb,\n  radixSortMsb,\n  shellSort,\n  timsort\n}\n\n/**\n * Strings representing the names of the implemented algorithms.\n */\n// I would like to implement the names with something like this:\n//\n// `export const algorithmNames = Object.keys(algorithms)`\n//\n// However, Tree shaking would then include the algotithms object to retrieve\n// the keys. This will bloat the main package and is sub optimal, so I have\n// resorted to just writing them here.\nexport const algorithmNames = [\n  'binaryInsertionSort',\n  'bubbleSort',\n  'heapSort',\n  'introsort',\n  'mergeSort',\n  // 'pancakeSort',\n  'quickSort',\n  'radixSortLsb',\n  'radixSortMsb',\n  'shellSort',\n  'timsort'\n]\n","import { Algorithm } from '../../types'\n\n/**\n * Bubble sort is a sorting algorithm that will sort an array of n comparable\n * elements.\n *\n * Bubble sort works by checking adjacent values. If the right value is less\n * than the left value, it swaps them. Otherwise it leaves them alone.\n *\n * After one pass of the entire array from the end to the beginning, the\n * smallest element in the array will be at the front. Then the pairs are all\n * checked again (but not the definitely sorted part).\n *\n * Since we only have one element sorted each pass, we will have to make a pass\n * for each (next smallest) element in the array, leading to a 'sum of the\n * numbers up to n' style time complexity, which is O(n^2).\n *\n * The space complexity however is very simple, we only keep track of the number\n * of definitely sorted values and our position in the current pass. This means\n * we have O(1) space complexity.\n * @param tracker\n */\nconst bubbleSort: Algorithm = ({ swap, compare, size }) => {\n  for (let i = 0; i < size - 1; i++) {\n    for (let j = size - 1; j > i; j--) {\n      if (compare(j, j - 1) < 0) swap(j, j - 1)\n    }\n  }\n}\n\nexport default bubbleSort\n","import { Algorithm } from '../../types'\n\nconst heapSort: Algorithm = ({ compare, swap, size }) => {\n  const heapify = (current: number, max: number) => {\n    let extreme, left, right\n\n    while (current < max) {\n      extreme = current\n      left = 2 * current + 1\n      right = 2 * current + 2\n\n      if (left < max && compare(extreme, left) < 0) extreme = left\n      if (right < max && compare(extreme, right) < 0) extreme = right\n\n      if (extreme === current) return\n      swap(current, extreme)\n      current = extreme\n    }\n  }\n\n  for (let i = 0; i < size; i++) heapify(size - i - 1, size)\n\n  for (let i = 0; i < size; i++) {\n    swap(0, size - i - 1)\n    heapify(0, size - i - 1)\n  }\n}\n\nexport default heapSort\n","import { Algorithm } from '../../types'\n\nconst mergeSort: Algorithm = ({ compare, malloc, memcpy, free, size }) => {\n  const merge = (low: number, mid: number, high: number) => {\n    const buffer = malloc(high - low)\n\n    let index = 0\n    let i = low\n    let j = mid\n    while (i < mid && j < high) {\n      if (compare(i, j) < 0) memcpy(i++, { buffer, index })\n      else memcpy(j++, { buffer, index })\n      index += 1\n    }\n    // copy remaining values to the end\n    if (i < mid) {\n      for (let k = i; k < mid; k++) {\n        memcpy(k, high - mid + k)\n      }\n    }\n    // copy back from memory\n    while (index--) {\n      memcpy({ buffer, index }, low + index)\n    }\n\n    free(buffer)\n  }\n\n  const split = (low: number, high: number) => {\n    const mid = low + Math.floor((high - low) / 2)\n\n    if (low < mid) {\n      split(low, mid)\n      split(mid, high)\n      merge(low, mid, high)\n    }\n  }\n  split(0, size)\n}\n\nexport default mergeSort\n","import { Algorithm } from '../../types'\n\n/**\n * Quick sort is a recursive sorting algorithm that will sort an array of `n`\n * comparable elements.\n *\n * Quick sort works on subarrays:\n * - It chooses a \"pivot\", any single element in the subarray. The pivot can be\n *   chosen arbitrarily, but difference choices will lead to different runtimes\n *   on different data.\n * - It then partitions the subarray into three portions:\n *   - A subarray of the elements less than or equal to than the pivot;\n *   - The pivot; and,\n *   - A subarray of the elements larger than the pivot.\n * - Then it runs the algorithm again on the two subarrays.\n *\n * Since the subarrays are smaller, the depth will be at most the length of the\n * array (if the smallest value in the array is the first element in every\n * subarray; the array was sorted already) and the sort will finish. Giving us a\n * worst case of O(n^2) time complexity.\n *\n * On average for random data however the split will be closer to the middle and\n * in the best case we will have half the values in each part. Thus in our best\n * case we will have O(n log(n)) time complexity.\n *\n * Since we are recursing, we will have O(1) space for each layer in the\n * recursion, so the worst case for our space complexity will be O(n).\n *\n * In the best case however we will have less layers alive at any one time,\n * meaning our space complexity would be O(log(n)).\n */\nconst quickSort: Algorithm = ({ swap, compare, size }) => {\n  const partition = (low: number, high: number) => {\n    const pivot = low\n\n    let i = high\n    for (let j = high; j > pivot; j--) {\n      if (compare(pivot, j) < 0) swap(j, i--)\n    }\n\n    swap(pivot, i)\n    return i\n  }\n\n  const sort = (low: number, high: number) => {\n    if (low < high) {\n      const mid = partition(low, high)\n      sort(low, mid - 1)\n      sort(mid + 1, high)\n    }\n  }\n\n  sort(0, size - 1)\n}\n\nexport default quickSort\n","import { Algorithm } from '../../types'\n\nconst lsbRadixSort: Algorithm = ({ nthBitSet, malloc, memcpy, free, size }) => {\n  for (let needle = 0; 1 << needle <= size; needle++) {\n    const buffer = malloc(size)\n    let zeroIndex = 0\n    let oneIndex = size - 1\n\n    // partition the values based on their binary representations.\n    for (let i = 0; i < size; i++) {\n      if (nthBitSet(i, needle)) {\n        memcpy(i, { buffer, index: oneIndex-- })\n      } else {\n        memcpy(i, { buffer, index: zeroIndex++ })\n      }\n    }\n\n    // put the values back in order.\n    // first the zeros\n    for (let i = 0; i < zeroIndex; i++) {\n      memcpy({ buffer, index: i }, i)\n    }\n    // then the ones\n    for (let i = 0; i < size - oneIndex - 1; i++) {\n      memcpy({ buffer, index: size - i - 1 }, zeroIndex + i)\n    }\n    free(buffer)\n  }\n}\n\nexport default lsbRadixSort\n","import { Algorithm } from '../../types'\n\n/**\n * The Radix Sort MSB can be performed in-place, while keeing track of the\n * different regions.\n */\nconst msbRadixSort: Algorithm = ({ nthBitSet, swap, size }) => {\n  const loStack = [0]\n  const hiStack = [size]\n  const needleStack = [Math.floor(Math.log2(size))]\n\n  while (loStack.length > 0) {\n    // if the lostack has a value, the histack will also have a value.\n    const lo = loStack.pop() as number\n    const hi = hiStack.pop() as number\n    const needle = needleStack.pop() as number\n\n    let zero = lo\n    let one = hi\n\n    while (zero < one) {\n      while (zero < one && !nthBitSet(zero, needle)) {\n        zero += 1\n      }\n      while (zero < one && nthBitSet(one - 1, needle)) {\n        one -= 1\n      }\n      if (zero < one) {\n        swap(zero, one - 1)\n      }\n    }\n    // the zero index is now the index of the first one\n    if (lo + 1 < zero && needle > 0) {\n      loStack.push(lo)\n      hiStack.push(zero)\n      needleStack.push(needle - 1)\n    }\n    if (zero + 1 < hi && needle > 0) {\n      loStack.push(zero)\n      hiStack.push(hi)\n      needleStack.push(needle - 1)\n    }\n  }\n}\n\nexport default msbRadixSort\n","import { Algorithm } from '../../types'\n\nconst shellSort: Algorithm = ({ compare, swap, size }) => {\n  let gap = ~~(size / 2)\n\n  while (gap > 0) {\n    for (let i = gap; i < size; i++) {\n      for (let j = i; j >= gap && compare(j - gap, j) > 0; j -= gap) {\n        swap(j - gap, j)\n      }\n    }\n    gap = ~~(gap / 2)\n  }\n}\n\nexport default shellSort\n","export const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const normal = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v)\n  return normal * stddev + mean\n}\n\nexport const boundAndRound = (min: number, target: number, max: number) => {\n  return Math.max(min, Math.min(max, Math.round(target)))\n}\n","import { Algorithm } from '../../types'\nimport cut from './cut'\nimport hinduShuffle from './hindu-shuffle'\nimport overhandShuffle from './overhand-shuffle'\nimport perfectRiffleShuffle from './perfect-riffle-shuffle'\nimport randomise from './randomise'\nimport reverse from './reverse'\nimport riffleShuffle from './riffle-shuffle'\n\nexport const algorithms: { [key: string]: Algorithm } = {\n  cut,\n  hinduShuffle,\n  overhandShuffle,\n  perfectRiffleShuffle,\n  randomise,\n  reverse,\n  riffleShuffle\n}\n\n/**\n * Strings representing the currently implemented unsorting algorithms.\n */\n// see `../sort/index.ts`.\nexport const algorithmNames = [\n  'cut',\n  'hinduShuffle',\n  'overhandShuffle',\n  'perfectRiffleShuffle',\n  'randomise',\n  'reverse',\n  'riffleShuffle'\n]\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst cut: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 6), size)\n\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n  for (let i = 0; i < size - split; i++) memcpy(split + i, i)\n  for (let i = 0; i < split; i++) memcpy({ buffer, index: i }, size - split + i)\n\n  free(buffer)\n}\n\nexport default cut\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst hinduShuffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  // determine the size of the group to be pulled\n  const group = boundAndRound(0, randomNormal(size / 5, size / 30), size - 1)\n\n  // then determine the first index\n  const start = boundAndRound(\n    0,\n    randomNormal((size - group) / 2, (size - group) / 6),\n    size - group\n  )\n\n  const buffer = malloc(group)\n\n  for (let i = 0; i < group; i++) memcpy(start + i, { buffer, index: i })\n  for (let i = 0; i < start; i++) memcpy(start - i - 1, start + group - i - 1)\n  for (let i = 0; i < group; i++) memcpy({ buffer, index: i }, i)\n\n  free(buffer)\n}\n\nexport default hinduShuffle\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\n/**\n * This shuffle is supposed to represent the normal shuffle that people do with\n * playing cards, and attempts to show the drawbacks of not shuffling properly.\n *\n * You will notice that runs often stay together, and the general order of the\n * entire array tends to reverse after each round\n */\nconst overhand: Algorithm = ({ malloc, memcpy, free, size }) => {\n  let processed = 0\n\n  while (processed < size) {\n    const group = Math.min(\n      size - processed,\n      boundAndRound(0, randomNormal(size / 7, size / 20), size)\n    )\n\n    const buffer = malloc(group)\n    // Copy the group into memory from the back\n    for (let i = 0; i < group; i++) {\n      memcpy(size - group + i, { buffer, index: i })\n    }\n    // Shift the remaining values\n    for (let i = 0; i < size - processed - group; i++) {\n      memcpy(size - group - i - 1, size - i - 1)\n    }\n    // Put the group at the front\n    for (let i = 0; i < group; i++) {\n      memcpy({ buffer, index: i }, processed + i)\n    }\n\n    free(buffer)\n    processed += group\n  }\n}\n\nexport default overhand\n","import { Algorithm } from '../../types'\n\nconst perfectRiffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const halfSize = size >> 1\n  const buffer = malloc(halfSize)\n  for (let i = 0; i < halfSize; i++) memcpy(i, { buffer, index: i })\n\n  let firstHalf = 0\n  let secondHalf = halfSize\n  let destination = 0\n  while (firstHalf < halfSize && secondHalf < size) {\n    memcpy({ buffer, index: firstHalf++ }, destination++)\n    memcpy(secondHalf++, destination++)\n  }\n  free(buffer)\n}\n\nexport default perfectRiffle\n","import { Algorithm } from '../../types'\n\n/**\n * This algorithm does not sort an array - it shuffles an array. The original\n * values will be created sorted; this algorithm will then *un-sort* the values\n * before one of the actual algorithms can sort it.\n */\nconst shuffle: Algorithm = ({ swap, size }) => {\n  for (let i = size - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    swap(i, j)\n  }\n}\n\nexport default shuffle\n","import { Algorithm } from '../../types'\n\n/**\n * Does what it says on the tin.\n */\nconst reverse: Algorithm = ({ swap, size }) => {\n  for (let i = 0; i < Math.floor(size / 2); i++) {\n    swap(i, size - i - 1)\n  }\n}\n\nexport default reverse\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst riffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 10), size)\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n\n  let pA = 0\n  let pB = split\n  let dest = 0\n\n  while (pA < split && pB < size) {\n    if (Math.random() > 0.5) {\n      memcpy({ buffer, index: pA++ }, dest++)\n    } else {\n      memcpy(pB++, dest++)\n    }\n  }\n  // the rest of B is already at the end.\n  while (pA < split) memcpy({ buffer, index: pA++ }, dest++)\n\n  free(buffer)\n}\n\nexport default riffle\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import { Move, MoveType } from './types'\n\n/**\n * The number of bytes that represent each move.\n *\n * The most space needed for a move is on a compare move, which containse 7\n * different numbers. These numbers can each fit in 32 bits, and the type can\n * fit in 8 bits.\n */\nexport const BYTES_PER_MOVE = 26\n\n/**\n * Provides the bility to take a `Move` object and encode it as a sequence of\n * numbers, to add to the\n *\n * @param move The move to be encoded.\n * @param buffer The ArrayBuffer representing all of the moves.\n * @param idx The index to insert into the list of moves at. (Not the number of\n * bytes)\n */\nexport const encodeMove = (move: Move, buffer: ArrayBuffer, idx: number) => {\n  const offset = idx * BYTES_PER_MOVE\n  const view = new DataView(buffer)\n  // We encode the type into the first byte.\n  view.setUint8(offset, move.type)\n\n  // Depending on the type, the encoding will be different.\n  switch (move.type) {\n    case MoveType.COMPARE:\n      // The only difference on a compare move is that we also encode the\n      // result of the compare. Therefore we encode them with the same code.\n      view.setUint32(offset + 1, move.i.buffer)\n      view.setUint32(offset + 5, move.i.index)\n      view.setUint32(offset + 9, move.i.value)\n      view.setUint32(offset + 13, move.j.buffer)\n      view.setUint32(offset + 17, move.j.index)\n      view.setUint32(offset + 21, move.j.value)\n      view.setInt8(offset + 25, move.result)\n      break\n    case MoveType.SWAP:\n      // Swap moves contain two indexes, consisting of a buffer id and an\n      // index in the buffer, plus the values at the indicies.\n      view.setUint32(offset + 1, move.i.buffer)\n      view.setUint32(offset + 5, move.i.index)\n      view.setUint32(offset + 9, move.i.value)\n      view.setUint32(offset + 13, move.j.buffer)\n      view.setUint32(offset + 17, move.j.index)\n      view.setUint32(offset + 21, move.j.value)\n      break\n    case MoveType.MALLOC:\n      // A malloc move stores the size and id of the buffer that was\n      // allocated.\n      view.setUint32(offset + 1, move.buffer)\n      view.setUint32(offset + 5, move.size)\n      break\n    case MoveType.MEMCPY:\n      view.setUint32(offset + 1, move.from.buffer)\n      view.setUint32(offset + 5, move.from.index)\n      view.setUint32(offset + 9, move.to.buffer)\n      view.setUint32(offset + 13, move.to.index)\n      view.setUint32(offset + 17, move.value)\n      view.setUint32(offset + 21, move.original)\n      break\n    case MoveType.FREE:\n      view.setUint32(offset + 1, move.buffer)\n      break\n    case MoveType.NTH_BIT_SET:\n      view.setUint32(offset + 1, move.index.buffer)\n      view.setUint32(offset + 5, move.index.index)\n      view.setUint8(offset + 9, move.result ? 1 : 0)\n      break\n  }\n}\n\n/**\n * Retrieves a move from an array buffer.\n *\n * @param buffer The buffer containing all of the moves.\n * @param idx The index of the move in the buffer.\n */\nexport const decodeMove = (buffer: ArrayBuffer, idx: number): Move => {\n  const offset = idx * BYTES_PER_MOVE\n  const view = new DataView(buffer)\n\n  const type = view.getUint8(offset) as MoveType\n\n  switch (type) {\n    case MoveType.COMPARE:\n      return {\n        type: MoveType.COMPARE,\n        i: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5),\n          value: view.getUint32(offset + 9)\n        },\n        j: {\n          buffer: view.getUint32(offset + 13),\n          index: view.getUint32(offset + 17),\n          value: view.getUint32(offset + 21)\n        },\n        result: view.getInt8(offset + 25)\n      }\n    case MoveType.SWAP:\n      return {\n        type: MoveType.SWAP,\n        i: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5),\n          value: view.getUint32(offset + 9)\n        },\n        j: {\n          buffer: view.getUint32(offset + 13),\n          index: view.getUint32(offset + 17),\n          value: view.getUint32(offset + 21)\n        }\n      }\n    case MoveType.MALLOC:\n      return {\n        type: MoveType.MALLOC,\n        buffer: view.getUint32(offset + 1),\n        size: view.getUint32(offset + 5)\n      }\n    case MoveType.MEMCPY:\n      return {\n        type: MoveType.MEMCPY,\n        from: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5)\n        },\n        to: {\n          buffer: view.getUint32(offset + 9),\n          index: view.getUint32(offset + 13)\n        },\n        value: view.getUint32(offset + 17),\n        original: view.getUint32(offset + 21)\n      }\n    case MoveType.FREE:\n      return {\n        type: MoveType.FREE,\n        buffer: view.getUint32(offset + 1)\n      }\n    case MoveType.NTH_BIT_SET:\n      return {\n        type: MoveType.NTH_BIT_SET,\n        index: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5)\n        },\n        result: view.getUint8(offset + 9) !== 0\n      }\n  }\n}\n\n/**\n * A wrapper for an `ArrayBuffer` that represents the different moves in a sort.\n *\n * An `ArrayBuffer` is preferable to a list of `Move` objects as it is\n * transferable between threads. An `ArrayBuffer` is however more difficult to\n * work with than a normal javascript `Array`, as it does not have any `push` or\n * `pop` methods.\n *\n * This class effectively implements a push method for an underlying array\n * buffer that can then be unwrapped when transfering between threads.\n */\nexport class TransferableMovesBuilder {\n  /**\n   * The buffer containing the encoded moves.\n   */\n  buffer: ArrayBuffer\n  /**\n   * The number of encoded moves in the buffer.\n   */\n  private size: number\n\n  constructor() {\n    this.size = 0\n    this.buffer = new ArrayBuffer(256 * BYTES_PER_MOVE)\n  }\n\n  /**\n   * Checks if there is enough space available in the current buffer for more\n   * moves. If not doubles the allocated space and copies the previous values.\n   *\n   * The doubling allows the time complexity of adding a move to amortise to\n   * O(1).\n   */\n  private growIfNeeded() {\n    if ((this.size + 1) * BYTES_PER_MOVE <= this.buffer.byteLength) {\n      return\n    }\n    // We need more space.\n\n    // Allocate a new buffer.\n    const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2)\n    const oldView = new DataView(this.buffer)\n    const newView = new DataView(newBuffer)\n\n    // Copy the previous bytes.\n    for (let i = 0; i < this.buffer.byteLength; i++) {\n      newView.setUint8(i, oldView.getUint8(i))\n    }\n\n    // Replace the buffer.\n    this.buffer = newBuffer\n  }\n\n  /**\n   * Encodes a `Move` object and adds it to the buffer.\n   *\n   * @param move The move to be encoded.\n   */\n  addMove(move: Move) {\n    // We want to add the encoded move to the array buffer\n    this.growIfNeeded()\n    encodeMove(move, this.buffer, this.size)\n    this.size += 1\n  }\n\n  get length() {\n    return this.size\n  }\n}\n","import { TransferableMovesBuilder } from './TransferableMovesList'\nimport { MoveType, Index } from './types'\n\nclass BufferIdPool {\n  private _next = 1\n  private _inUse: Set<number> = new Set([])\n\n  next(): number {\n    const id = this._next++\n    this._inUse.add(id)\n    return id\n  }\n\n  free(id: number) {\n    this._inUse.delete(id)\n  }\n\n  inUse(id: number) {\n    return this._inUse.has(id)\n  }\n\n  /** Iterates over the keys in use. */\n  [Symbol.iterator]() {\n    return this._inUse[Symbol.iterator]()\n  }\n}\n\n/**\n * Abstracts the values array to the sorting algorithm so that the moves can be\n * monitored and recorded.\n */\nexport default class Tracker {\n  /** A copy of the original values that the Tracker was instantiated with. */\n  private original: number[]\n  /** A list of the current buffers in use for the sort. */\n  private buffers: {\n    /** The main values array */\n    0: number[]\n    [key: number]: number[]\n  }\n  /** An object that will give and keep track of unique keys. */\n  private bufferIdPool: BufferIdPool\n  /** The moves that have been done to the values. */\n  private moves: TransferableMovesBuilder\n  /** The length of the values array. */\n  readonly size: number\n\n  constructor(values: number[]) {\n    this.original = [...values]\n    this.buffers = {\n      0: values\n    }\n    this.bufferIdPool = new BufferIdPool()\n    this.size = values.length\n    this.moves = new TransferableMovesBuilder()\n\n    this.swap = this.swap.bind(this)\n    this.compare = this.compare.bind(this)\n    this.malloc = this.malloc.bind(this)\n    this.memcpy = this.memcpy.bind(this)\n    this.free = this.free.bind(this)\n    this.nthBitSet = this.nthBitSet.bind(this)\n  }\n\n  get values() {\n    return this.buffers[0]\n  }\n\n  getMoves(): [ArrayBuffer, number] {\n    return [this.moves.buffer, this.moves.length]\n  }\n\n  /**\n   * Swaps the values at indicies i and j.\n   */\n  swap(iIndex: Index | number, jIndex: Index | number): void {\n    // normalise the inputs\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const iBuffer = this.buffers[i.buffer]\n    const jBuffer = this.buffers[j.buffer]\n\n    iBuffer[i.index] = j.value\n    jBuffer[j.index] = i.value\n\n    this.moves.addMove({ type: MoveType.SWAP, i, j })\n  }\n\n  /**\n   * Compares the values at indicies i and j and returns:\n   *\n   * - **-1** If the value at i is less than the value at j;\n   * - **0** If the value at i is equal to the value at j; or,\n   * - **1** If the value at i is greater than the value at j.\n   */\n  compare(iIndex: Index | number, jIndex: Index | number) {\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const result = Math.sign(i.value - j.value)\n\n    this.moves.addMove({ type: MoveType.COMPARE, i, j, result })\n\n    return result\n  }\n\n  /**\n   * Comparable to the C malloc function, however instead of returning a pointer\n   * to the allocated buffer, will return an id to the buffer that was\n   * allocated.\n   */\n  malloc(size: number) {\n    const buffer = this.bufferIdPool.next()\n\n    this.buffers[buffer] = new Array(size)\n\n    this.moves.addMove({ type: MoveType.MALLOC, size, buffer })\n\n    return buffer\n  }\n\n  /**\n   * Copies a value from one buffer to another.\n   */\n  memcpy(from: Index | number, to: Index | number) {\n    from = this.normaliseIndex(from)\n    to = this.normaliseIndex(to)\n\n    // copy\n    const value = this.buffers[from.buffer][from.index]\n\n    // remember\n    const original = this.buffers[to.buffer][to.index]\n\n    // paste\n    this.buffers[to.buffer][to.index] = value\n\n    this.moves.addMove({ type: MoveType.MEMCPY, from, to, value, original })\n  }\n\n  /**\n   * Releases a chunk of memory.\n   *\n   * @param buffer The id of the buffer to free.\n   */\n  free(buffer: number) {\n    // we cant free the main values\n    if (buffer > 0) {\n      delete this.buffers[buffer]\n      this.bufferIdPool.free(buffer)\n      this.moves.addMove({ type: MoveType.FREE, buffer })\n    }\n  }\n\n  /**\n   * Returns a boolean that is true if and only if the nth (little endian) bit\n   * of the value at a given index is set.\n   *\n   * @param givenIndex The index of the value to check.\n   * @param n The bit (little endian) of the value to check.\n   */\n  nthBitSet(givenIndex: Index | number, n: number) {\n    const index = this.normaliseIndex(givenIndex)\n\n    const result = Boolean(index.value & (1 << n))\n\n    this.moves.addMove({ type: MoveType.NTH_BIT_SET, index, result })\n\n    return result\n  }\n\n  /**\n   * Normalises an index so that it has a buffer property. Most of the functions\n   * will work by just passing a number as the index, which should index the\n   * main values array.\n   */\n  private normaliseIndex(index: Index | number): Index & { value: number } {\n    if (typeof index === 'number') index = { buffer: 0, index }\n    const value = this.buffers[index.buffer][index.index]\n    return { ...index, value }\n  }\n}\n","import * as Comlink from 'comlink'\nimport { algorithms as sorts } from './algorithms/sort'\nimport { algorithms as unsorts } from './algorithms/unsort'\nimport { WorkerCalculateMethod } from './types'\nimport Tracker from './Tracker'\n\nconst calculate: WorkerCalculateMethod = (type, name, values) => {\n  const algorithms = type === 'sort' ? sorts : unsorts\n  if (!(name in algorithms)) {\n    throw new Error(`sort (${name}) not implemented`)\n  }\n\n  console.log(`Worker: Performing ${type}: ${name}`)\n\n  const tracker = new Tracker(values)\n  algorithms[name](tracker)\n\n  console.log(`Worker: Finished calculating ${type}: ${name}`)\n\n  // We now have the calculated moves object, which we want to transfer to the\n  // main thread. We also send back the final state of the values.\n  const [buffer, numMoves] = tracker.getMoves()\n  return [Comlink.transfer(buffer, [buffer]), numMoves, tracker.values]\n}\n\nComlink.expose(calculate)\n"],"sourceRoot":""}