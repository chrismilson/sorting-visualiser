{"version":3,"sources":["sort/types.ts","ui/components/Display.tsx","ui/components/Button.tsx","ui/components/Menu.tsx","ui/hooks/use-values.ts","sort/algorithms/unsort/common.ts","sort/algorithms/unsort/index.ts","sort/algorithms/unsort/cut.ts","sort/algorithms/unsort/hindu-shuffle.ts","sort/algorithms/unsort/overhand-shuffle.ts","sort/algorithms/unsort/perfect-riffle-shuffle.ts","sort/algorithms/unsort/randomise.ts","sort/algorithms/unsort/reverse.ts","sort/algorithms/unsort/riffle-shuffle.ts","sort/algorithms/sort/binary-insertion-sort.ts","sort/algorithms/sort/bubble-sort.ts","sort/algorithms/sort/heap-sort.ts","sort/algorithms/sort/merge-sort.ts","sort/algorithms/sort/quick-sort.ts","sort/algorithms/sort/radix-sort-lsb.ts","sort/algorithms/sort/radix-sort-msb.ts","sort/algorithms/sort/shell-sort.ts","sort/algorithms/sort/tim-sort.ts","sort/algorithms/sort/index.ts","sort/StatTracker.ts","sort/Untracker.ts","sort/Tracker.ts","ui/hooks/use-algorithms.ts","ui/hooks/use-toggle.ts","ui/hooks/use-block.ts","ui/components/Stats.tsx","ui/App.tsx","index.tsx"],"names":["MoveType","Direction","Display","props","values","moveRef","untracker","draw","useCallback","ctx","canvas","width","height","length","setTransform","fillStyle","currentValues","forEach","value","index","fillRect","frame","drawFrame","requestAnimationFrame","i","clearRect","forEachInExtra","_buffer","save","globalAlpha","NaN","restore","move","current","type","SWAP","j","COMPARE","result","color","MEMCPY","from","to","NTH_BIT_SET","Math","floor","drawMove","cancelAnimationFrame","canvasRef","useCanvas","className","ref","Button","name","handler","disabled","keyStr","keyCode","children","buttonAttributes","camelCaseName","replace","_x","y","toLowerCase","toUpperCase","useRef","useEffect","undefined","listener","e","key","click","preventDefault","window","addEventListener","removeEventListener","title","onClick","IconButton","Icon","Menu","reverse","reverseStatus","status","restart","speedDown","stepBack","play","playStatus","stepForward","speedUp","stats","sizeUp","sizeDown","unsort","sort","useState","spinning","setSpinning","extra","setExtra","FaRedoAlt","style","transition","transform","onTransitionEnd","FaBackward","FaStepBackward","FaPause","FaPlay","FaSyncAlt","FaStepForward","FaForward","FaEllipsisV","list","map","camelCase","FaInfo","FaPlus","FaMinus","useValues","size","useMemo","push","randomNormal","mean","stddev","u","v","random","normal","sqrt","log","cos","PI","boundAndRound","min","target","max","round","algorithms","cut","malloc","memcpy","free","split","buffer","hinduShuffle","group","start","overhandShuffle","processed","perfectRiffleShuffle","halfSize","firstHalf","secondHalf","destination","randomise","swap","riffleShuffle","pA","pB","dest","binaryInsertionSort","compare","findIndex","low","high","mid","bubbleSort","heapSort","heapify","extreme","left","right","mergeSort","k","merge","quickSort","pivot","partition","lsbRadixSort","nthBitSet","needle","zeroIndex","oneIndex","msbRadixSort","loStack","hiStack","needleStack","log2","lo","pop","hi","zero","one","shellSort","gap","MergeState","pending","minGallop","radixSortLsb","radixSortMsb","timsort","countRun","n","gallopLeft","mark","hint","fromBuffer","indexFrom","base","lastOffset","offset","maxOffset","temp","gallopRight","binarySearch","shift","insertionSort","mergeLo","mergeState","nA","nB","countA","countB","gallop","mergeHi","mergeAt","len","splice","ignoreAtFront","mergeCollapse","remaining","MIN_RUN","r","calculateMinRun","mergeForceCollapse","StatTracker","comparisons","reads","writes","multiplier","this","MALLOC","FREE","modifyBy","Untracker","moves","original","buffers","bufferIds","currentMove","statistics","0","Set","hasNext","bind","hasPrevious","next","previous","reset","add","delete","subtract","id","direction","FORWARD","stepsPerFrame","options","onCompletion","step","withRecord","withAnimationFrame","run","hasStep","withInterval","interval","setInterval","clearInterval","timeUntilCompletion","stepsRemaining","animateStepsPerFrame","callback","Symbol","iterator","BufferIdPool","_next","_inUse","has","Tracker","bufferIdPool","iIndex","jIndex","normaliseIndex","iBuffer","jBuffer","sign","Array","givenIndex","Boolean","useAlgorithms","unsortedValues","setUnsortedValues","unsortWith","block","unblock","unsortingAlgorithms","copy","tracker","untrack","animateUntilCompletion","sortString","setSortString","sortUntracker","setSortUntracker","invalid","a","sortingAlgorithms","calculate","then","setSort","useToggle","first","second","setValue","toggle","firstOrSecond","useBlock","count","setCount","blocking","Stats","display","setComparisons","setReads","setWrites","App","BACKWARD","changeDirection","setPlay","displayStats","setDisplayStats","speed","setSpeed","setSize","pow","oppositeDirection","Object","keys","algorithm","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.17f05bd2.chunk.js","sourcesContent":["import Tracker from './Tracker'\n\n/** The type that each sorting algorithm should implement */\nexport type Algorithm = (tracker: Tracker) => void\n\n/** The different types of moves an algorithm can use */\nexport enum MoveType {\n  SWAP = 'SWAP',\n  COMPARE = 'COMPARE',\n  MALLOC = 'MALLOC',\n  MEMCPY = 'MEMCPY',\n  FREE = 'FREE',\n  NTH_BIT_SET = 'NTH_BIT_SET'\n}\n\n/**\n * Represents an index in an allocated buffer.\n */\nexport type Index = { buffer: number; index: number }\n\nexport interface SwapMove {\n  type: MoveType.SWAP\n  i: Index & { value: number }\n  j: Index & { value: number }\n}\n\nexport interface CompareMove {\n  type: MoveType.COMPARE\n  i: Index & { value: number }\n  j: Index & { value: number }\n  result: number\n}\n\nexport interface MallocMove {\n  type: MoveType.MALLOC\n  size: number\n  buffer: number\n}\n\nexport interface MemcpyMove {\n  type: MoveType.MEMCPY\n  from: Index\n  to: Index\n  value: number\n  original: number\n}\n\nexport interface FreeMove {\n  type: MoveType.FREE\n  buffer: number\n}\n\nexport interface NthBitSetMove {\n  type: MoveType.NTH_BIT_SET\n  index: Index\n  result: boolean\n}\n\nexport type Move =\n  | SwapMove\n  | CompareMove\n  | MallocMove\n  | MemcpyMove\n  | FreeMove\n  | NthBitSetMove\n\n/** Represents the direction of flow of an algorithm */\nexport enum Direction {\n  FORWARD = 'FORWARD',\n  BACKWARD = 'BACKWARD'\n}\n","import React, { useCallback } from 'react'\nimport useCanvas, { DrawingMethod } from 'react-hooks-use-drawing-canvas'\nimport { MoveType, Move } from '../../sort/types'\nimport Untracker from '../../sort/Untracker'\nimport './Display.scss'\n\n/** continuously displays values on the screen */\nconst Display: React.FC<{\n  values: number[]\n  moveRef: React.MutableRefObject<Move | undefined>\n  untracker?: Untracker\n}> = props => {\n  const { values, moveRef, untracker } = props\n\n  const draw = useCallback<DrawingMethod>(\n    ctx => {\n      // resize the pixels, not just a maths transform\n      ctx.canvas.width = ctx.canvas.height = values.length\n      ctx.setTransform(1, 0, 0, -1, 0, values.length)\n\n      ctx.fillStyle = 'rgb(87,163,207)'\n\n      const currentValues = [...values]\n      values.forEach((value, index) => {\n        ctx.fillRect(index, 0, 1, value)\n      })\n\n      const drawMove = () => {\n        const move = moveRef.current\n        if (!move) return\n        switch (move.type) {\n          case MoveType.SWAP: {\n            const { i, j } = move\n            ctx.save()\n            ctx.fillStyle = 'cyan'\n            ctx.fillRect(i.index, 0, 1, j.value)\n            ctx.fillRect(j.index, 0, 1, i.value)\n            ctx.restore()\n\n            // We make sure that the values are repainted on the next frame by\n            // setting the current value to NaN.\n            currentValues[i.index] = currentValues[j.index] = NaN\n            break\n          }\n          case MoveType.COMPARE: {\n            const { i, j, result } = move\n\n            const color = ['lime', 'orange', 'red']\n            ctx.save()\n            ctx.fillStyle = color[1 + result]\n            ctx.fillRect(i.index, 0, 1, i.value)\n\n            ctx.fillStyle = color[1 - result]\n            ctx.fillRect(j.index, 0, 1, j.value)\n            ctx.restore()\n\n            currentValues[i.index] = currentValues[j.index] = NaN\n            break\n          }\n          case MoveType.MEMCPY: {\n            const { from, to, value } = move\n\n            ctx.save()\n            ctx.fillStyle = 'gold'\n            ctx.fillRect(from.index, 0, 1, value)\n            ctx.fillRect(to.index, 0, 1, value)\n            ctx.restore()\n\n            currentValues[from.index] = currentValues[to.index] = NaN\n            break\n          }\n          case MoveType.NTH_BIT_SET: {\n            const {\n              index: { index },\n              result\n            } = move\n\n            ctx.save()\n            ctx.fillStyle = 'black'\n            ctx.fillRect(\n              index + 0.1,\n              result ? Math.floor(values.length / 2) : 0,\n              0.8,\n              Math.floor(values.length / 2)\n            )\n            ctx.restore()\n\n            currentValues[index] = NaN\n            break\n          }\n        }\n      }\n\n      let frame: number\n      const drawFrame = () => {\n        frame = requestAnimationFrame(drawFrame)\n        // check the main values\n        for (let i = 0; i < values.length; i++) {\n          if (currentValues[i] !== values[i]) {\n            ctx.clearRect(i, 0, 1, values.length)\n            ctx.fillRect(i, 0, 1, values[i])\n            currentValues[i] = values[i]\n          }\n        }\n\n        // then the extra memory\n        untracker?.forEachInExtra((_buffer, index, value) => {\n          ctx.save()\n          ctx.globalAlpha = 0.2\n          ctx.fillStyle = 'purple'\n\n          ctx.fillRect(index, 0, 1, value)\n          // repaint the extra values each time\n          currentValues[index] = NaN\n\n          ctx.restore()\n        })\n\n        drawMove()\n      }\n\n      drawFrame()\n\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    },\n    [values, moveRef, untracker]\n  )\n\n  const canvasRef = useCanvas(draw)\n\n  return <canvas className=\"Display\" ref={canvasRef} />\n}\n\nexport default Display\n","import React, { useRef, useEffect } from 'react'\nimport { IconType } from 'react-icons/lib/cjs'\nimport './Button.scss'\n\ntype ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n  name: string\n  handler: () => void\n  disabled?: boolean\n  keyStr?: string\n  keyCode?: number\n}\n\nconst Button: React.FC<ButtonProps> = ({\n  name,\n  handler,\n  disabled,\n  keyStr,\n  keyCode,\n  children,\n  className,\n  ...buttonAttributes\n}) => {\n  const camelCaseName = name\n    .replace(/^(.)/, (_x, y) => y.toLowerCase())\n    .replace(/ (.)/g, (_x, y) => y.toUpperCase())\n\n  // We want to make it possible to specify a keyboard event that will also fire\n  // the button.\n  const ref = useRef<HTMLButtonElement>(null)\n  useEffect(() => {\n    if (keyStr !== undefined || keyCode !== undefined) {\n      const listener = (e: KeyboardEvent) => {\n        // By clicking the button instead of calling the callback, we make sure\n        // that the callback is not fired if the button is disabled\n        if (e.key === keyStr || e.keyCode === keyCode) {\n          ref.current?.click()\n          if (e.key === ' ') e.preventDefault()\n        }\n      }\n      window.addEventListener('keydown', listener)\n      return () => {\n        window.removeEventListener('keydown', listener)\n      }\n    }\n  }, [ref, keyStr, keyCode])\n\n  return (\n    <button\n      ref={ref}\n      className={`Button ${className} ${camelCaseName}`}\n      title={name}\n      onClick={handler}\n      disabled={disabled}\n      {...buttonAttributes}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport const IconButton: React.FC<ButtonProps & { Icon: IconType }> = ({\n  Icon,\n  ...props\n}) => (\n  <Button {...props} className={`${props.className} Icon`}>\n    <Icon className=\"icon\" />\n  </Button>\n)\n\nexport default Button\n","import React, { useState } from 'react'\nimport {\n  FaRedoAlt,\n  FaBackward,\n  FaStepBackward,\n  FaPlay,\n  FaSyncAlt,\n  FaForward,\n  FaStepForward,\n  FaEllipsisV,\n  FaPlus,\n  FaMinus,\n  FaPause,\n  FaInfo\n} from 'react-icons/fa'\nimport Button, { IconButton } from './Button'\nimport './Menu.scss'\n\ninterface ButtonProps {\n  handler: () => void\n  keyStr?: string\n  keyCode?: number\n  disabled?: boolean\n}\n\nconst Menu: React.FC<{\n  reverse: ButtonProps & { status: boolean }\n  restart: ButtonProps\n  speedDown: ButtonProps\n  stepBack: ButtonProps\n  play: ButtonProps & { status: boolean }\n  stepForward: ButtonProps\n  speedUp: ButtonProps\n  stats: ButtonProps\n  sizeUp: ButtonProps\n  sizeDown: ButtonProps\n  unsort: {\n    disabled: boolean\n    list: string[]\n    handler(key: string): void\n  }\n  sort: {\n    current: string\n    list: string[]\n    handler(key: string): void\n  }\n}> = ({\n  reverse: { status: reverseStatus, ...reverse },\n  restart,\n  speedDown,\n  stepBack,\n  play: { status: playStatus, ...play },\n  stepForward,\n  speedUp,\n  stats,\n  sizeUp,\n  sizeDown,\n  unsort,\n  sort\n}) => {\n  const [spinning, setSpinning] = useState(false)\n  const [extra, setExtra] = useState(false)\n\n  return (\n    <div className=\"Menu\">\n      <IconButton\n        name=\"restart\"\n        Icon={FaRedoAlt}\n        style={\n          spinning\n            ? {\n                transition: 'transform 300ms',\n                transform: `rotate(${360}deg)`\n              }\n            : {}\n        }\n        onTransitionEnd={() => setSpinning(false)}\n        {...restart}\n        handler={() => {\n          restart.handler()\n          setSpinning(true)\n        }}\n      />\n      <IconButton name=\"speed down\" Icon={FaBackward} {...speedDown} />\n      <IconButton name=\"step back\" Icon={FaStepBackward} {...stepBack} />\n      <div className=\"playPauseWithReverse\">\n        <IconButton\n          name=\"play\"\n          Icon={playStatus ? FaPause : FaPlay}\n          style={{\n            transition: 'transform 100ms',\n            transform: `rotate(${reverseStatus ? 180 : 0}deg)`\n          }}\n          {...play}\n        />\n        <IconButton name=\"reverse\" Icon={FaSyncAlt} {...reverse} />\n      </div>\n      <IconButton name=\"step forward\" Icon={FaStepForward} {...stepForward} />\n      <IconButton name=\"speed up\" Icon={FaForward} {...speedUp} />\n      <div className={`extra ${extra ? 'show' : 'hide'}`}>\n        <IconButton\n          name=\"extra options\"\n          Icon={FaEllipsisV}\n          keyCode={27}\n          handler={() => setExtra(!extra)}\n        />\n        <div className=\"buttons\">\n          <div className=\"algorithms\">\n            <div className=\"unsort\">\n              {unsort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    unsort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  disabled={unsort.disabled}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n            <div className=\"sort\">\n              {sort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    setExtra(false)\n                    sort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  className={sort.current === camelCase ? 'active' : ''}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n          </div>\n          <IconButton name=\"show stats\" Icon={FaInfo} {...stats} />\n          <IconButton name=\"size up\" Icon={FaPlus} {...sizeUp} />\n          <IconButton name=\"size down\" Icon={FaMinus} {...sizeDown} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default Menu\n","import { useMemo } from 'react'\n\n/**\n * Supplies a sorted array containing the integers from 1 to size.\n *\n * The array reference will change when the size changes.\n */\nconst useValues = (size: number) => {\n  return useMemo(() => {\n    const values = []\n\n    for (let i = 1; i <= size; i++) values.push(i)\n\n    return values\n  }, [size])\n}\n\nexport default useValues\n","export const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const normal = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v)\n  return normal * stddev + mean\n}\n\nexport const boundAndRound = (min: number, target: number, max: number) => {\n  return Math.max(min, Math.min(max, Math.round(target)))\n}\n","import { Algorithm } from '../../types'\nimport cut from './cut'\nimport hinduShuffle from './hindu-shuffle'\nimport overhandShuffle from './overhand-shuffle'\nimport perfectRiffleShuffle from './perfect-riffle-shuffle'\nimport randomise from './randomise'\nimport reverse from './reverse'\nimport riffleShuffle from './riffle-shuffle'\n\nconst algorithms: { [key: string]: Algorithm } = {\n  cut,\n  hinduShuffle,\n  overhandShuffle,\n  perfectRiffleShuffle,\n  randomise,\n  reverse,\n  riffleShuffle\n}\n\nexport default algorithms\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst cut: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 6), size)\n\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n  for (let i = 0; i < size - split; i++) memcpy(split + i, i)\n  for (let i = 0; i < split; i++) memcpy({ buffer, index: i }, size - split + i)\n\n  free(buffer)\n}\n\nexport default cut\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst hinduShuffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  // determine the size of the group to be pulled\n  const group = boundAndRound(0, randomNormal(size / 5, size / 30), size - 1)\n\n  // then determine the first index\n  const start = boundAndRound(\n    0,\n    randomNormal((size - group) / 2, (size - group) / 6),\n    size - group\n  )\n\n  const buffer = malloc(group)\n\n  for (let i = 0; i < group; i++) memcpy(start + i, { buffer, index: i })\n  for (let i = 0; i < start; i++) memcpy(start - i - 1, start + group - i - 1)\n  for (let i = 0; i < group; i++) memcpy({ buffer, index: i }, i)\n\n  free(buffer)\n}\n\nexport default hinduShuffle\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\n/**\n * This shuffle is supposed to represent the normal shuffle that people do with\n * playing cards, and attempts to show the drawbacks of not shuffling properly.\n *\n * You will notice that runs often stay together, and the general order of the\n * entire array tends to reverse after each round\n */\nconst overhand: Algorithm = ({ malloc, memcpy, free, size }) => {\n  let processed = 0\n\n  while (processed < size) {\n    const group = Math.min(\n      size - processed,\n      boundAndRound(0, randomNormal(size / 7, size / 20), size)\n    )\n\n    const buffer = malloc(group)\n    // Copy the group into memory from the back\n    for (let i = 0; i < group; i++) {\n      memcpy(size - group + i, { buffer, index: i })\n    }\n    // Shift the remaining values\n    for (let i = 0; i < size - processed - group; i++) {\n      memcpy(size - group - i - 1, size - i - 1)\n    }\n    // Put the group at the front\n    for (let i = 0; i < group; i++) {\n      memcpy({ buffer, index: i }, processed + i)\n    }\n\n    free(buffer)\n    processed += group\n  }\n}\n\nexport default overhand\n","import { Algorithm } from '../../types'\n\nconst perfectRiffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const halfSize = size >> 1\n  const buffer = malloc(halfSize)\n  for (let i = 0; i < halfSize; i++) memcpy(i, { buffer, index: i })\n\n  let firstHalf = 0\n  let secondHalf = halfSize\n  let destination = 0\n  while (firstHalf < halfSize && secondHalf < size) {\n    memcpy({ buffer, index: firstHalf++ }, destination++)\n    memcpy(secondHalf++, destination++)\n  }\n  free(buffer)\n}\n\nexport default perfectRiffle\n","import { Algorithm } from '../../types'\n\n/**\n * This algorithm does not sort an array - it shuffles an array. The original\n * values will be created sorted; this algorithm will then *un-sort* the values\n * before one of the actual algorithms can sort it.\n */\nconst shuffle: Algorithm = ({ swap, size }) => {\n  for (let i = size - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    swap(i, j)\n  }\n}\n\nexport default shuffle\n","import { Algorithm } from '../../types'\n\n/**\n * Does what it says on the tin.\n */\nconst reverse: Algorithm = ({ swap, size }) => {\n  for (let i = 0; i < Math.floor(size / 2); i++) {\n    swap(i, size - i - 1)\n  }\n}\n\nexport default reverse\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst riffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 10), size)\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n\n  let pA = 0\n  let pB = split\n  let dest = 0\n\n  while (pA < split && pB < size) {\n    if (Math.random() > 0.5) {\n      memcpy({ buffer, index: pA++ }, dest++)\n    } else {\n      memcpy(pB++, dest++)\n    }\n  }\n  // the rest of B is already at the end.\n  while (pA < split) memcpy({ buffer, index: pA++ }, dest++)\n\n  free(buffer)\n}\n\nexport default riffle\n","import { Algorithm } from '../../types'\n\nconst binaryInsertionSort: Algorithm = ({ compare, swap, size }) => {\n  const findIndex = (target: number) => {\n    let low = 0\n    let high = target\n\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n      if (compare(target, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  for (let i = 1; i < size; i++) {\n    const index = findIndex(i)\n    for (let j = i; j > index; j--) {\n      swap(j, j - 1)\n    }\n  }\n}\n\nexport default binaryInsertionSort\n","import { Algorithm } from '../../types'\n\n/**\n * Bubble sort is a sorting algorithm that will sort an array of n comparable\n * elements.\n *\n * Bubble sort works by checking adjacent values. If the right value is less\n * than the left value, it swaps them. Otherwise it leaves them alone.\n *\n * After one pass of the entire array from the end to the beginning, the\n * smallest element in the array will be at the front. Then the pairs are all\n * checked again (but not the definitely sorted part).\n *\n * Since we only have one element sorted each pass, we will have to make a pass\n * for each (next smallest) element in the array, leading to a 'sum of the\n * numbers up to n' style time complexity, which is O(n^2).\n *\n * The space complexity however is very simple, we only keep track of the number\n * of definitely sorted values and our position in the current pass. This means\n * we have O(1) space complexity.\n * @param tracker\n */\nconst bubbleSort: Algorithm = ({ swap, compare, size }) => {\n  for (let i = 0; i < size - 1; i++) {\n    for (let j = size - 1; j > i; j--) {\n      if (compare(j, j - 1) < 0) swap(j, j - 1)\n    }\n  }\n}\n\nexport default bubbleSort\n","import { Algorithm } from '../../types'\n\nconst heapSort: Algorithm = ({ compare, swap, size }) => {\n  const heapify = (current: number, max: number) => {\n    let extreme, left, right\n\n    while (current < max) {\n      extreme = current\n      left = 2 * current + 1\n      right = 2 * current + 2\n\n      if (left < max && compare(extreme, left) < 0) extreme = left\n      if (right < max && compare(extreme, right) < 0) extreme = right\n\n      if (extreme === current) return\n      swap(current, extreme)\n      current = extreme\n    }\n  }\n\n  for (let i = 0; i < size; i++) heapify(size - i - 1, size)\n\n  for (let i = 0; i < size; i++) {\n    swap(0, size - i - 1)\n    heapify(0, size - i - 1)\n  }\n}\n\nexport default heapSort\n","import { Algorithm } from '../../types'\n\nconst mergeSort: Algorithm = ({ compare, malloc, memcpy, free, size }) => {\n  const merge = (low: number, mid: number, high: number) => {\n    const buffer = malloc(high - low)\n\n    let index = 0\n    let i = low\n    let j = mid\n    while (i < mid && j < high) {\n      if (compare(i, j) < 0) memcpy(i++, { buffer, index })\n      else memcpy(j++, { buffer, index })\n      index += 1\n    }\n    // copy remaining values to the end\n    if (i < mid) {\n      for (let k = i; k < mid; k++) {\n        memcpy(k, high - mid + k)\n      }\n    }\n    // copy back from memory\n    while (index--) {\n      memcpy({ buffer, index }, low + index)\n    }\n\n    free(buffer)\n  }\n\n  const split = (low: number, high: number) => {\n    const mid = low + Math.floor((high - low) / 2)\n\n    if (low < mid) {\n      split(low, mid)\n      split(mid, high)\n      merge(low, mid, high)\n    }\n  }\n  split(0, size)\n}\n\nexport default mergeSort\n","import { Algorithm } from '../../types'\n\n/**\n * Quick sort is a recursive sorting algorithm that will sort an array of `n`\n * comparable elements.\n *\n * Quick sort works on subarrays:\n * - It chooses a \"pivot\", any single element in the subarray. The pivot can be\n *   chosen arbitrarily, but difference choices will lead to different runtimes\n *   on different data.\n * - It then partitions the subarray into three portions:\n *   - A subarray of the elements less than or equal to than the pivot;\n *   - The pivot; and,\n *   - A subarray of the elements larger than the pivot.\n * - Then it runs the algorithm again on the two subarrays.\n *\n * Since the subarrays are smaller, the depth will be at most the length of the\n * array (if the smallest value in the array is the first element in every\n * subarray; the array was sorted already) and the sort will finish. Giving us a\n * worst case of O(n^2) time complexity.\n *\n * On average for random data however the split will be closer to the middle and\n * in the best case we will have half the values in each part. Thus in our best\n * case we will have O(n log(n)) time complexity.\n *\n * Since we are recursing, we will have O(1) space for each layer in the\n * recursion, so the worst case for our space complexity will be O(n).\n *\n * In the best case however we will have less layers alive at any one time,\n * meaning our space complexity would be O(log(n)).\n */\nconst quickSort: Algorithm = ({ swap, compare, size }) => {\n  const partition = (low: number, high: number) => {\n    const pivot = low\n\n    let i = high\n    for (let j = high; j > pivot; j--) {\n      if (compare(pivot, j) < 0) swap(j, i--)\n    }\n\n    swap(pivot, i)\n    return i\n  }\n\n  const sort = (low: number, high: number) => {\n    if (low < high) {\n      const mid = partition(low, high)\n      sort(low, mid - 1)\n      sort(mid + 1, high)\n    }\n  }\n\n  sort(0, size - 1)\n}\n\nexport default quickSort\n","import { Algorithm } from '../../types'\n\nconst lsbRadixSort: Algorithm = ({ nthBitSet, malloc, memcpy, free, size }) => {\n  for (let needle = 0; 1 << needle <= size; needle++) {\n    const buffer = malloc(size)\n    let zeroIndex = 0\n    let oneIndex = size - 1\n\n    // partition the values based on their binary representations.\n    for (let i = 0; i < size; i++) {\n      if (nthBitSet(i, needle)) {\n        memcpy(i, { buffer, index: oneIndex-- })\n      } else {\n        memcpy(i, { buffer, index: zeroIndex++ })\n      }\n    }\n\n    // put the values back in order.\n    // first the zeros\n    for (let i = 0; i < zeroIndex; i++) {\n      memcpy({ buffer, index: i }, i)\n    }\n    // then the ones\n    for (let i = 0; i < size - oneIndex - 1; i++) {\n      memcpy({ buffer, index: size - i - 1 }, zeroIndex + i)\n    }\n    free(buffer)\n  }\n}\n\nexport default lsbRadixSort\n","import { Algorithm } from '../../types'\n\n/**\n * The Radix Sort MSB can be performed in-place, while keeing track of the\n * different regions.\n */\nconst msbRadixSort: Algorithm = ({ nthBitSet, swap, size }) => {\n  const loStack = [0]\n  const hiStack = [size]\n  const needleStack = [Math.floor(Math.log2(size))]\n\n  while (loStack.length > 0) {\n    // if the lostack has a value, the histack will also have a value.\n    const lo = loStack.pop() as number\n    const hi = hiStack.pop() as number\n    const needle = needleStack.pop() as number\n\n    let zero = lo\n    let one = hi\n\n    while (zero < one) {\n      while (zero < one && !nthBitSet(zero, needle)) {\n        zero += 1\n      }\n      while (zero < one && nthBitSet(one - 1, needle)) {\n        one -= 1\n      }\n      if (zero < one) {\n        swap(zero, one - 1)\n      }\n    }\n    // the zero index is now the index of the first one\n    if (lo + 1 < zero && needle > 0) {\n      loStack.push(lo)\n      hiStack.push(zero)\n      needleStack.push(needle - 1)\n    }\n    if (zero + 1 < hi && needle > 0) {\n      loStack.push(zero)\n      hiStack.push(hi)\n      needleStack.push(needle - 1)\n    }\n  }\n}\n\nexport default msbRadixSort\n","import { Algorithm } from '../../types'\n\nconst shellSort: Algorithm = ({ compare, swap, size }) => {\n  let gap = ~~(size / 2)\n\n  while (gap > 0) {\n    for (let i = gap; i < size; i++) {\n      for (let j = i; j >= gap && compare(j - gap, j) > 0; j -= gap) {\n        swap(j - gap, j)\n      }\n    }\n    gap = ~~(gap / 2)\n  }\n}\n\nexport default shellSort\n","import { Algorithm, Index } from '../../types'\n\ninterface Slice {\n  base: number\n  len: number\n}\n\nclass MergeState {\n  pending: Slice[] = []\n  minGallop = 7\n}\n\n/**\n * Adapted from the listsort algorithm in python\n * http://svn.python.org/projects/python/trunk/Objects/listobject.c\n */\nconst timsort: Algorithm = ({ compare, swap, malloc, memcpy, free, size }) => {\n  /**\n   * Returns the length of a run starting at a given index (up to a given\n   * index).\n   *\n   * If the run is descending the value will be the negative length of the run.\n   */\n  const countRun = (low: number, high: number) => {\n    if (low === high - 1) return 1\n    let n = low + 1\n    if (compare(low, n) > 0) {\n      while (n < high && compare(n - 1, n) > 0) n++\n      // returns negative to signify decending run\n      return low - n\n    }\n    while (n < high && compare(n - 1, n) <= 0) n++\n    return n - low\n  }\n\n  /**\n   * Simmilar to binary search, except first finds a good lower and upper bound\n   * before searching.\n   */\n  const gallopLeft = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      // mark should be somwhere in [hint, size]\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset = hint + lastOffset\n      offset = hint + offset\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n    return offset\n  }\n\n  const gallopRight = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    /** optionally set the buffer that from should access */\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset += hint\n      offset += hint\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n\n    return offset\n  }\n\n  /**\n   * Finds the index of a value (or the index a value should be inserted at) in\n   * sorted data.\n   */\n  const binarySearch = (low: number, high: number, mark: number) => {\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n\n      if (compare(mark, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  /**\n   * Shifts values to the right, wrapping the last value to the front.\n   */\n  const shift = (low: number, high: number) => {\n    for (let i = high; i > low; i--) swap(i - 1, i)\n  }\n\n  /**\n   * Performs a binary insertion sort on a chunk.\n   */\n  const insertionSort = (low: number, high: number) => {\n    for (let i = low; i < high; i++) shift(binarySearch(low, i, i), i)\n  }\n\n  /**\n   * Reverses a chunk.\n   */\n  const reverse = (low: number, high: number) => {\n    const mid = Math.floor((high - low) / 2)\n    for (let i = 0; i < mid; i++) swap(low + i, high - i - 1)\n  }\n\n  /**\n   * Timsort's merge low method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeLo = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the A buffer into extra memory\n    const buffer = malloc(nA)\n    for (let index = 0; index < nA; index++) {\n      memcpy(pA + index, { buffer, index })\n    }\n\n    let destination = pA\n    pA = 0 // this is now the index in extra memory\n    let countA = 0\n    let countB = 0\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n\n        countA = gallopRight(pB, pA, nA, 0, buffer)\n        for (let i = 0; i < countA; i++) {\n          memcpy({ buffer, index: pA++ }, destination++)\n        }\n        nA -= countA\n        // if (nA === 0) return\n\n        countB = gallopLeft({ buffer, index: pA }, pB, nB, 0)\n        for (let i = 0; i < countB; i++) {\n          memcpy(pB++, destination++)\n        }\n        nB -= countB\n        // if (nB === 0) return\n      }\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: pA }, pB) < 0) {\n        memcpy({ buffer, index: pA++ }, destination++)\n        nA -= 1\n        countA += 1\n        countB = 0\n      } else {\n        memcpy(pB++, destination++)\n        nB -= 1\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n\n    while (nA-- > 0) memcpy({ buffer, index: pA++ }, destination++)\n\n    free(buffer)\n  }\n\n  /**\n   * Timsort's merge high method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeHi = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the B buffer into memory\n    const buffer = malloc(nB)\n    for (let index = 0; index < nB; index++) {\n      memcpy(pB + index, { buffer, index })\n    }\n\n    let destination = pB + nB\n    let countA = 0 // number of times A won in a row\n    let countB = 0 // number of times B won in a row\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n        countA = nA - gallopRight({ buffer, index: nB - 1 }, pA, nA, nA - 1)\n        for (let i = 0; i < countA; i++) {\n          memcpy(pA + --nA, --destination)\n        }\n        // if (nA === 0) return\n\n        countB = nB - gallopLeft(pA + nA - 1, 0, nB, nB - 1, buffer)\n        for (let i = 0; i < countB; i++) {\n          memcpy({ buffer, index: --nB }, --destination)\n        }\n        // if (nB === 0) return\n      }\n      // punishment for not gallopping anymore\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: nB - 1 }, pA + nA - 1) <= 0) {\n        memcpy(pA + --nA, --destination)\n        countA += 1\n        countB = 0\n      } else {\n        memcpy({ buffer, index: --nB }, --destination)\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n    while (nB > 0) memcpy({ buffer, index: --nB }, --destination)\n\n    free(buffer)\n  }\n\n  /** Merges two slices */\n  const mergeAt = (mergeState: MergeState, i: number) => {\n    const { pending } = mergeState\n    let pA = pending[i].base\n    let nA = pending[i].len\n    const pB = pending[i + 1].base\n    let nB = pending[i + 1].len\n\n    // record the length of the combined runs.\n    pending[i].len = nA + nB\n    // remove the chunk that will be merged.\n    pending.splice(i + 1, 1)\n\n    // Where does b start in a? Elements before that can be ignored.\n    const ignoreAtFront = gallopRight(pB, pA, nA, 0)\n    pA += ignoreAtFront\n    nA -= ignoreAtFront\n\n    nB = gallopLeft(pA + nA - 1, pB, nB, nB - 1)\n\n    const merge = nA <= nB ? mergeLo : mergeHi\n    merge(mergeState, pA, nA, pB, nB)\n  }\n\n  const mergeCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len <= pending[n].len + pending[n + 1].len) {\n        if (pending[n - 1].len < pending[n + 1].len) n -= 1\n        mergeAt(mergeState, n)\n      } else if (pending[n].len <= pending[n + 1].len) {\n        mergeAt(mergeState, n)\n      } else break\n    }\n  }\n\n  const mergeForceCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len < pending[n + 1].len) n -= 1\n      mergeAt(mergeState, n)\n    }\n  }\n\n  /** Calculates the optimal minimum length of a run. */\n  const calculateMinRun = (length: number) => {\n    let r = 0 // becomes 1 if any 1 bits are shifted off.\n\n    // The true version of timsort uses 64 as a max, min size, we will use 16 so\n    // that the merging can be seen at smaller sizes\n    // while (length >= 64) {\n    while (length >= 16) {\n      r |= length & 1\n      length >>= 1\n    }\n\n    return length + r\n  }\n\n  const mergeState = new MergeState()\n  let remaining = size\n  let low = 0\n\n  const MIN_RUN = calculateMinRun(size)\n  while (remaining > 0) {\n    let n = countRun(low, size)\n\n    // reverse if descending\n    if (n < 0) {\n      n *= -1\n      reverse(low, low + n)\n    }\n\n    // exdend if too short\n    if (n < MIN_RUN) {\n      n = Math.min(MIN_RUN, remaining)\n      insertionSort(low, low + n)\n    }\n\n    // push run onto pending stack and maybe merge\n    mergeState.pending.push({\n      base: low,\n      len: n\n    })\n    mergeCollapse(mergeState)\n\n    low += n\n    remaining -= n\n  }\n  mergeForceCollapse(mergeState)\n}\n\nexport default timsort\n","import { Algorithm } from '../../types'\nimport binaryInsertionSort from './binary-insertion-sort'\nimport bubbleSort from './bubble-sort'\nimport heapSort from './heap-sort'\nimport mergeSort from './merge-sort'\n// import pancakeSort from './pancake-sort'\nimport quickSort from './quick-sort'\nimport radixSortLsb from './radix-sort-lsb'\nimport radixSortMsb from './radix-sort-msb'\nimport shellSort from './shell-sort'\nimport timsort from './tim-sort'\n\nconst algorithms: { [key: string]: Algorithm } = {\n  binaryInsertionSort,\n  bubbleSort,\n  heapSort,\n  mergeSort,\n  // pancakeSort,\n  quickSort,\n  radixSortLsb,\n  radixSortMsb,\n  shellSort,\n  timsort\n}\n\nexport default algorithms\n","import { Move, MoveType } from './types'\n\nexport default class StatTracker {\n  comparisons = 0\n  reads = 0\n  writes = 0\n\n  private modifyBy(move: Move, multiplier: number) {\n    switch (move.type) {\n      case MoveType.COMPARE:\n        this.reads += 2 * multiplier\n        this.comparisons += 1 * multiplier\n        break\n      case MoveType.SWAP:\n        this.reads += 2 * multiplier\n        this.writes += 2 * multiplier\n        break\n      case MoveType.MALLOC:\n        break\n      case MoveType.MEMCPY:\n        this.reads += 1 * multiplier\n        this.writes += 1 * multiplier\n        break\n      case MoveType.FREE:\n        break\n      case MoveType.NTH_BIT_SET:\n        this.reads += 1 * multiplier\n        break\n    }\n  }\n\n  add(move: Move) {\n    this.modifyBy(move, 1)\n  }\n\n  subtract(move: Move) {\n    this.modifyBy(move, -1)\n  }\n}\n","import { MoveType, Move, Direction } from './types'\nimport StatTracker from './StatTracker'\n\n/**\n * Just as the Tracker class is for recording the algorithms. The UnTracker is\n * for replaying a tracker.\n */\nexport default class Untracker {\n  private original: number[]\n  private buffers: {\n    [key: number]: number[]\n  }\n  private bufferIds: Set<number>\n  private moves: Move[]\n  private currentMove: number\n  statistics: StatTracker\n\n  constructor(moves: Move[], values: number[], original: number[]) {\n    this.moves = moves\n    this.buffers = {\n      0: values\n    }\n    this.bufferIds = new Set()\n    this.original = original\n\n    // A tracker is not expected to undo any of the moves that were performed on\n    // the data. The untracker has to take this into account, so by default will\n    // be finished.\n    this.currentMove = 0\n\n    this.statistics = new StatTracker()\n\n    this.hasNext = this.hasNext.bind(this)\n    this.hasPrevious = this.hasPrevious.bind(this)\n    this.next = this.next.bind(this)\n    this.previous = this.previous.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  /** Returns true if there is a future move available to do. */\n  private hasNext() {\n    return this.currentMove < this.moves.length\n  }\n\n  /** Returns true if there is a previous move available to undo. */\n  private hasPrevious() {\n    return this.currentMove > 0\n  }\n\n  next() {\n    if (!this.hasNext()) return\n\n    const move = this.moves[this.currentMove++]\n\n    this.statistics.add(move)\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = j.value\n          this.buffers[j.buffer][j.index] = i.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n          this.buffers[buffer] = []\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const { from, to } = move\n\n          const value = this.buffers[from.buffer][from.index]\n          this.buffers[to.buffer][to.index] = value\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  previous() {\n    if (!this.hasPrevious()) return\n\n    const move = this.moves[--this.currentMove]\n\n    this.statistics.subtract(move)\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = i.value\n          this.buffers[j.buffer][j.index] = j.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const {\n            to: { buffer, index },\n            original\n          } = move\n\n          this.buffers[buffer][index] = original\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  /** Returns the values array to its original state. */\n  reset() {\n    // delete the extra buffers\n    this.bufferIds.forEach(id => {\n      delete this.buffers[id]\n    })\n\n    for (let i = 0; i < this.original.length; i++) {\n      this.buffers[0][i] = this.original[i]\n    }\n\n    this.currentMove = 0\n  }\n\n  /** Advances the untracker in a direction determined by the reverse boolean */\n  step(direction: Direction) {\n    return direction === Direction.FORWARD ? this.next() : this.previous()\n  }\n\n  /**\n   * Returns true if the untracker has a valid move available in the determined\n   * direction\n   */\n  hasStep(direction: Direction) {\n    return direction === Direction.FORWARD ? this.hasNext() : this.hasPrevious()\n  }\n\n  /**\n   * Animates the advancement of steps in a given direction.\n   *\n   * @param stepsPerFrame The number of steps to be advanced per frame\n   * @param onCompletion A callback to be run if all of the steps have been\n   * completed.\n   */\n  animateStepsPerFrame(\n    stepsPerFrame: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const { onCompletion, moveRef } = options\n\n    const base = (stepsPerFrame: number) => {\n      for (let i = 0; i < stepsPerFrame; i++) this.step(direction)\n    }\n\n    // if the moveRef is defined then record the last move\n    const withRecord = moveRef\n      ? () => {\n          base(stepsPerFrame - 1)\n          moveRef.current = this.step(direction)\n        }\n      : () => base(stepsPerFrame)\n\n    const withAnimationFrame = () => {\n      let frame: number\n      const run = () => {\n        withRecord()\n        if (this.hasStep(direction)) frame = requestAnimationFrame(run)\n        else if (onCompletion) onCompletion()\n      }\n      run()\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    }\n    const withInterval = () => {\n      const interval = setInterval(() => {\n        withRecord()\n        if (!this.hasStep(direction)) {\n          clearInterval(interval)\n          if (onCompletion) onCompletion()\n        }\n      }, 1 / (0.06 * stepsPerFrame))\n      return () => {\n        clearInterval(interval)\n      }\n    }\n\n    return stepsPerFrame >= 1 ? withAnimationFrame() : withInterval()\n  }\n\n  animateUntilCompletion(\n    timeUntilCompletion: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const stepsRemaining =\n      direction === Direction.FORWARD\n        ? this.moves.length - this.currentMove\n        : this.currentMove\n\n    // there are 0.06 frames per millisecond\n    const stepsPerFrame = stepsRemaining / (timeUntilCompletion * 0.06)\n\n    return this.animateStepsPerFrame(stepsPerFrame, direction, options)\n  }\n\n  forEachInExtra(\n    callback: (buffer: number, index: number, value: number) => void\n  ) {\n    this.bufferIds.forEach(buffer => {\n      this.buffers[buffer].forEach((value, index) =>\n        callback(buffer, index, value)\n      )\n    })\n  }\n}\n","import { MoveType, Move, Index } from './types'\nimport Untracker from './Untracker'\n\nclass BufferIdPool {\n  private _next = 1\n  private _inUse: Set<number> = new Set([])\n\n  next(): number {\n    const id = this._next++\n    this._inUse.add(id)\n    return id\n  }\n\n  free(id: number) {\n    this._inUse.delete(id)\n  }\n\n  inUse(id: number) {\n    return this._inUse.has(id)\n  }\n\n  /** Iterates over the keys in use. */\n  [Symbol.iterator]() {\n    return this._inUse[Symbol.iterator]()\n  }\n}\n\n/**\n * Abstracts the values array to the sorting algorithm so that the moves can be\n * monitored and recorded.\n */\nexport default class Tracker {\n  /** A copy of the original values that the Tracker was instantiated with. */\n  private original: number[]\n  /** A list of the current buffers in use for the sort. */\n  private buffers: {\n    /** The main values array */\n    0: number[]\n    [key: number]: number[]\n  }\n  /** An object that will give and keep track of unique keys. */\n  private bufferIdPool: BufferIdPool\n  /** The moves that have been done to the values. */\n  private moves: Move[]\n  /** The length of the values array. */\n  readonly size: number\n\n  constructor(values: number[]) {\n    this.original = [...values]\n    this.buffers = {\n      0: values\n    }\n    this.bufferIdPool = new BufferIdPool()\n    this.size = values.length\n    this.moves = []\n\n    this.swap = this.swap.bind(this)\n    this.compare = this.compare.bind(this)\n    this.malloc = this.malloc.bind(this)\n    this.memcpy = this.memcpy.bind(this)\n    this.free = this.free.bind(this)\n    this.nthBitSet = this.nthBitSet.bind(this)\n  }\n\n  /**\n   * Returns an untracker with the moves tracked by the tracker.\n   *\n   * @param values The array to modify while untracking\n   */\n  untrack(values = this.buffers[0]) {\n    return new Untracker(this.moves, values, this.original)\n  }\n\n  /**\n   * Swaps the values at indicies i and j.\n   */\n  swap(iIndex: Index | number, jIndex: Index | number): void {\n    // normalise the inputs\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const iBuffer = this.buffers[i.buffer]\n    const jBuffer = this.buffers[j.buffer]\n\n    iBuffer[i.index] = j.value\n    jBuffer[j.index] = i.value\n\n    this.moves.push({ type: MoveType.SWAP, i, j })\n  }\n\n  /**\n   * Compares the values at indicies i and j and returns:\n   *\n   * - **-1** If the value at i is less than the value at j;\n   * - **0** If the value at i is equal to the value at j; or,\n   * - **1** If the value at i is greater than the value at j.\n   */\n  compare(iIndex: Index | number, jIndex: Index | number) {\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const result = Math.sign(i.value - j.value)\n\n    this.moves.push({ type: MoveType.COMPARE, i, j, result })\n\n    return result\n  }\n\n  /**\n   * Comparable to the C malloc function, however instead of returning a pointer\n   * to the allocated buffer, will return an id to the buffer that was\n   * allocated.\n   */\n  malloc(size: number) {\n    const buffer = this.bufferIdPool.next()\n\n    this.buffers[buffer] = new Array(size)\n\n    this.moves.push({ type: MoveType.MALLOC, size, buffer })\n\n    return buffer\n  }\n\n  /**\n   * Copies a value from one buffer to another.\n   */\n  memcpy(from: Index | number, to: Index | number) {\n    from = this.normaliseIndex(from)\n    to = this.normaliseIndex(to)\n\n    // copy\n    const value = this.buffers[from.buffer][from.index]\n\n    // remember\n    const original = this.buffers[to.buffer][to.index]\n\n    // paste\n    this.buffers[to.buffer][to.index] = value\n\n    this.moves.push({ type: MoveType.MEMCPY, from, to, value, original })\n  }\n\n  /**\n   * Releases a chunk of memory.\n   *\n   * @param buffer The id of the buffer to free.\n   */\n  free(buffer: number) {\n    // we cant free the main values\n    if (buffer > 0) {\n      delete this.buffers[buffer]\n      this.bufferIdPool.free(buffer)\n      this.moves.push({ type: MoveType.FREE, buffer })\n    }\n  }\n\n  /**\n   * Returns a boolean that is true if and only if the nth (little endian) bit\n   * of the value at a given index is set.\n   *\n   * @param givenIndex The index of the value to check.\n   * @param n The bit (little endian) of the value to check.\n   */\n  nthBitSet(givenIndex: Index | number, n: number) {\n    const index = this.normaliseIndex(givenIndex)\n\n    const result = Boolean(index.value & (1 << n))\n\n    this.moves.push({ type: MoveType.NTH_BIT_SET, index, result })\n\n    return result\n  }\n\n  /**\n   * Normalises an index so that it has a buffer property. Most of the functions\n   * will work by just passing a number as the index, which should index the\n   * main values array.\n   */\n  private normaliseIndex(index: Index | number): Index & { value: number } {\n    if (typeof index === 'number') index = { buffer: 0, index }\n    const value = this.buffers[index.buffer][index.index]\n    return { ...index, value }\n  }\n}\n","import { useState, useCallback, useEffect } from 'react'\nimport unsortingAlgorithms from '../../sort/algorithms/unsort'\nimport sortingAlgorithms from '../../sort/algorithms/sort'\nimport Tracker from '../../sort/Tracker'\nimport Untracker from '../../sort/Untracker'\nimport { Direction } from '../../sort/types'\n\nconst useAlgorithms = (values: number[]) => {\n  /**\n   * The original values will be displayed on the screen.\n   *\n   * This array is intended to be modified by the unsorting algorithm so that\n   * the unsort can be untracked on the original values, and the sort can be\n   * calculated while the unsort is running.\n   */\n  const [unsortedValues, setUnsortedValues] = useState([...values])\n  useEffect(() => setUnsortedValues([...values]), [values])\n\n  const unsortWith = useCallback(\n    (name: string, block?: () => void, unblock?: () => void) => {\n      if (name === 'nothing') {\n        setUnsortedValues([...values])\n        return\n      }\n      if (!(name in unsortingAlgorithms)) return\n\n      if (block && unblock) block()\n\n      const copy = [...values]\n      const tracker = new Tracker(copy)\n\n      unsortingAlgorithms[name](tracker)\n\n      setUnsortedValues(copy)\n      const untracker = tracker.untrack(values)\n\n      untracker.animateUntilCompletion(500, Direction.FORWARD, {\n        onCompletion: () => {\n          if (unblock) unblock()\n        }\n      })\n    },\n    [values]\n  )\n\n  /** A string identifying the currently in use sort. */\n  const [sortString, setSortString] = useState('heapSort')\n\n  /** The untracker for the sort */\n  const [sortUntracker, setSortUntracker] = useState<Untracker>()\n\n  useEffect(() => {\n    let invalid = false\n\n    const calculate = async () => {\n      if (!(sortString in sortingAlgorithms)) return\n      const tracker = new Tracker(unsortedValues)\n\n      // if calculation is made async we can put an await in front of this.\n      sortingAlgorithms[sortString](tracker)\n\n      const untracker = tracker.untrack(values)\n\n      return untracker\n    }\n\n    calculate().then(untracker => !invalid && setSortUntracker(untracker))\n\n    return () => {\n      invalid = true\n    }\n  }, [sortString, unsortedValues, values])\n\n  const setSort = useCallback((name: string) => {\n    setSortString(name)\n  }, [])\n\n  return {\n    unsortWith,\n    sort: sortUntracker,\n    setSort,\n    sortString\n  }\n}\n\nexport default useAlgorithms\n","import { useState, useCallback } from 'react'\n\n/** Toggles between two values */\nfunction useToggle<T>(first: T, second: T): [T, (set?: T) => void] {\n  const [value, setValue] = useState(true)\n  const toggle = useCallback(\n    (firstOrSecond?: T) => {\n      if (firstOrSecond === first) setValue(true)\n      else if (firstOrSecond === second) setValue(false)\n      else setValue(value => !value)\n    },\n    [first, second]\n  )\n\n  return [value ? first : second, toggle]\n}\n\nexport default useToggle\n","import { useState, useCallback, useMemo } from 'react'\n\nconst useBlock = () => {\n  const [count, setCount] = useState(0)\n\n  const blocking = count > 0\n  const block = useCallback(() => {\n    setCount(count => count + 1)\n  }, [])\n\n  const unblock = useCallback(() => {\n    setCount(count => Math.max(0, count - 1))\n  }, [])\n\n  return useMemo(() => ({ blocking, block, unblock }), [\n    blocking,\n    block,\n    unblock\n  ])\n}\n\nexport default useBlock\n","import React, { useEffect, useState } from 'react'\nimport StatTracker from '../../sort/StatTracker'\nimport './Stats.scss'\n\nconst Stats: React.FC<{\n  stats?: StatTracker\n  display: boolean\n}> = ({ stats = { comparisons: 0, reads: 0, writes: 0 }, display }) => {\n  const [comparisons, setComparisons] = useState(stats.comparisons)\n  const [reads, setReads] = useState(stats.reads)\n  const [writes, setWrites] = useState(stats.writes)\n\n  /** update the values if they have changed  */\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setComparisons(stats.comparisons)\n      setReads(stats.reads)\n      setWrites(stats.writes)\n    }, 50)\n    return () => clearInterval(interval)\n  }, [stats])\n\n  return (\n    <div className={`Stats ${display ? 'show' : 'hide'}`}>\n      <div className=\"stat comparisons\">Comparisons: {comparisons}</div>\n      <div className=\"stat reads\">Reads: {reads}</div>\n      <div className=\"stat writes\">Writes: {writes}</div>\n    </div>\n  )\n}\n\nexport default Stats\n","import React, { useState, useEffect, useRef } from 'react'\nimport Display from './components/Display'\nimport Menu from './components/Menu'\nimport useValues from './hooks/use-values'\nimport useAlgorithms from './hooks/use-algorithms'\nimport useToggle from './hooks/use-toggle'\nimport useBlock from './hooks/use-block'\nimport sortingAlgorithms from '../sort/algorithms/sort'\nimport unsortingAlgorithms from '../sort/algorithms/unsort'\nimport { Direction, Move } from '../sort/types'\nimport './App.scss'\nimport Stats from './components/Stats'\n\nconst App: React.FC = () => {\n  const [direction, changeDirection] = useToggle(\n    Direction.FORWARD,\n    Direction.BACKWARD\n  )\n  const [play, setPlay] = useState(false)\n  const [displayStats, setDisplayStats] = useState(false)\n  const { blocking, block, unblock } = useBlock()\n\n  /** The number of steps per frame is exponential in speed */\n  const minSpeed = -10\n  const maxSpeed = 10\n  const [speed, setSpeed] = useState(-4)\n\n  /** The length of the values array is exponantial in size */\n  const minSize = 3\n  const maxSize = 20\n  const [size, setSize] = useState(12)\n\n  const values = useValues(Math.floor(Math.pow(1.5, size)))\n\n  const { unsortWith, sort, setSort, sortString } = useAlgorithms(values)\n\n  const moveRef = useRef<Move | undefined>()\n  useEffect(() => {\n    moveRef.current = undefined\n    // Any blocking action occurring will refresh the current move.\n  }, [moveRef, blocking])\n\n  useEffect(() => {\n    if (play) {\n      return sort?.animateStepsPerFrame(Math.pow(1.3, speed), direction, {\n        onCompletion: () => {\n          setPlay(false)\n          changeDirection()\n          moveRef.current = undefined\n        },\n        moveRef\n      })\n    }\n  }, [play, sort, speed, direction, changeDirection, moveRef])\n\n  return (\n    <div className=\"App\">\n      <Menu\n        restart={{\n          disabled: blocking || !sort,\n          keyStr: 'r',\n          handler: () => {\n            changeDirection(Direction.FORWARD)\n            setPlay(false)\n            block()\n\n            sort?.animateUntilCompletion(1000, Direction.BACKWARD, {\n              onCompletion: () => unblock()\n            })\n          }\n        }}\n        speedDown={{\n          disabled: blocking || !sort,\n          // if playing leftArrow decreases speed\n          keyCode: play ? 37 : undefined,\n          handler: () => setSpeed(Math.max(minSpeed, speed - 1))\n        }}\n        stepBack={{\n          disabled: blocking || !sort,\n          // if not playing leftArrow steps back\n          keyCode: play ? undefined : 37,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.BACKWARD)\n          }\n        }}\n        play={{\n          disabled: blocking || !sort,\n          handler: () => setPlay(!play),\n          keyStr: ' ',\n          status: play\n        }}\n        reverse={{\n          disabled: blocking || !sort,\n          keyStr: '`',\n          handler: () => {\n            const oppositeDirection =\n              direction === Direction.BACKWARD\n                ? Direction.FORWARD\n                : Direction.BACKWARD\n            if (sort?.hasStep(oppositeDirection)) changeDirection()\n          },\n          status: direction === Direction.BACKWARD\n        }}\n        stepForward={{\n          disabled: blocking || !sort,\n          // if not playing rightArrow steps forward\n          keyCode: play ? undefined : 39,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.FORWARD)\n          }\n        }}\n        speedUp={{\n          disabled: blocking || !sort,\n          // if playing rightArrow increases speed\n          keyCode: play ? 39 : undefined,\n          handler: () => setSpeed(Math.min(maxSpeed, speed + 1))\n        }}\n        stats={{\n          keyStr: 's',\n          handler: () => setDisplayStats(v => !v)\n        }}\n        sizeUp={{\n          keyCode: 38,\n          handler: () => setSize(Math.min(maxSize, size + 1))\n        }}\n        sizeDown={{\n          keyCode: 40,\n          handler: () => setSize(Math.max(minSize, size - 1))\n        }}\n        unsort={{\n          disabled: blocking,\n          list: Object.keys(unsortingAlgorithms),\n          handler: algorithm => {\n            if (algorithm in unsortingAlgorithms) {\n              setPlay(false)\n              changeDirection(Direction.FORWARD)\n\n              unsortWith(algorithm, block, unblock)\n            }\n          }\n        }}\n        sort={{\n          current: sortString,\n          list: Object.keys(sortingAlgorithms),\n          handler: algorithm => {\n            if (algorithm in sortingAlgorithms && algorithm !== sortString) {\n              moveRef.current = undefined\n              unsortWith('nothing')\n              setSort(algorithm)\n            }\n          }\n        }}\n      />\n      <Stats stats={sort?.statistics} display={displayStats} />\n      <Display values={values} moveRef={moveRef} untracker={sort} />\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './ui/App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}