{"version":3,"sources":["sort/types.ts","sort/index.ts","ui/components/Display.tsx","ui/components/Button.tsx","ui/components/Menu.tsx","ui/hooks/use-values.ts","sort/StatTracker.ts","sort/TransferableMovesList.ts","sort/Untracker.ts","ui/hooks/use-algorithms.ts","ui/hooks/use-toggle.ts","ui/hooks/use-block.ts","sort/algorithms/sort/index.ts","sort/algorithms/unsort/index.ts","ui/components/Stats.tsx","ui/App.tsx","index.tsx"],"names":["MoveType","Direction","proxy","Display","props","values","moveRef","untracker","draw","useCallback","ctx","canvas","width","height","length","setTransform","fillStyle","currentValues","forEach","value","index","fillRect","frame","drawFrame","requestAnimationFrame","i","clearRect","forEachInExtra","_buffer","save","globalAlpha","NaN","restore","move","current","type","SWAP","j","COMPARE","result","color","MEMCPY","from","to","NTH_BIT_SET","Math","floor","drawMove","cancelAnimationFrame","canvasRef","useCanvas","className","ref","Button","name","handler","disabled","keyStr","keyCode","children","buttonAttributes","camelCaseName","replace","_x","y","toLowerCase","toUpperCase","useRef","useEffect","undefined","listener","e","key","click","preventDefault","window","addEventListener","removeEventListener","title","onClick","IconButton","Icon","Menu","reverse","reverseStatus","status","restart","speedDown","stepBack","play","playStatus","stepForward","speedUp","stats","sizeUp","sizeDown","unsort","sort","useState","spinning","setSpinning","extra","setExtra","FaRedoAlt","style","transition","transform","onTransitionEnd","FaBackward","FaStepBackward","FaPause","FaPlay","FaSyncAlt","FaStepForward","FaForward","FaEllipsisV","list","map","camelCase","FaInfo","FaPlus","FaMinus","useValues","size","useMemo","push","StatTracker","comparisons","reads","writes","multiplier","this","MALLOC","FREE","modifyBy","decodeMove","buffer","idx","offset","view","DataView","getUint8","getUint32","getInt8","original","Untracker","moves","numMoves","buffers","bufferIds","currentMove","statistics","0","Set","hasNext","bind","hasPrevious","next","previous","reset","add","delete","subtract","id","direction","FORWARD","stepsPerFrame","options","onCompletion","base","step","withRecord","withAnimationFrame","run","hasStep","withInterval","interval","setInterval","clearInterval","timeUntilCompletion","stepsRemaining","animateStepsPerFrame","callback","init","a","Worker","default","worker","Comlink","calculate","valuesToSort","valuesToTrack","console","log","calculatedValues","useAlgorithms","unsortedValues","setUnsortedValues","unsortWith","block","unblock","then","animateUntilCompletion","sortString","setSortString","sortUntracker","setSortUntracker","invalid","catch","error","setSort","useToggle","first","second","setValue","toggle","firstOrSecond","useBlock","count","setCount","blocking","max","algorithmNames","Stats","display","setComparisons","setReads","setWrites","App","BACKWARD","changeDirection","setPlay","displayStats","setDisplayStats","speed","setSpeed","setSize","pow","lock","cleaned","navigator","wakeLock","request","sentinel","release","oppositeDirection","min","v","unsortNames","algorithm","includes","sortNames","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.96b22dc3.chunk.js","sourcesContent":["import Tracker from './Tracker'\nimport Untracker from './Untracker'\n\n/** The type that each sorting algorithm should implement */\nexport type Algorithm = (tracker: Tracker) => void\n\n/** The different types of moves an algorithm can use */\nexport enum MoveType {\n  SWAP = 1,\n  COMPARE = 2,\n  MALLOC = 3,\n  MEMCPY = 4,\n  FREE = 5,\n  NTH_BIT_SET = 6\n}\n\n/**\n * Represents an index in an allocated buffer.\n */\nexport type Index = { buffer: number; index: number }\n\nexport interface SwapMove {\n  type: MoveType.SWAP\n  i: Index & { value: number }\n  j: Index & { value: number }\n}\n\nexport interface CompareMove {\n  type: MoveType.COMPARE\n  i: Index & { value: number }\n  j: Index & { value: number }\n  result: number\n}\n\nexport interface MallocMove {\n  type: MoveType.MALLOC\n  size: number\n  buffer: number\n}\n\nexport interface MemcpyMove {\n  type: MoveType.MEMCPY\n  from: Index\n  to: Index\n  value: number\n  original: number\n}\n\nexport interface FreeMove {\n  type: MoveType.FREE\n  buffer: number\n}\n\nexport interface NthBitSetMove {\n  type: MoveType.NTH_BIT_SET\n  index: Index\n  result: boolean\n}\n\nexport type Move =\n  | SwapMove\n  | CompareMove\n  | MallocMove\n  | MemcpyMove\n  | FreeMove\n  | NthBitSetMove\n\n/** Represents the direction of flow of an algorithm */\nexport enum Direction {\n  FORWARD = 'FORWARD',\n  BACKWARD = 'BACKWARD'\n}\n\n/**\n * The signature for the worker's calculate method.\n *\n * The return value will consist of the array buffer representing the moves, the\n * number of encoded moves in the array buffer, and the final state of the\n * values array.\n */\nexport type WorkerCalculateMethod = (\n  type: 'sort' | 'unsort',\n  name: string,\n  values: number[]\n) => [ArrayBuffer, number, number[]]\n\n/**\n * The signature for the main thread's calculate method, wrapping the worker.\n */\nexport type MainThreadCalculateMethod = (\n  type: 'sort' | 'unsort',\n  name: string,\n  valuesToSort: number[],\n  valuesToTrack: number[]\n) => Promise<[Untracker, number[]]>\n","/**\n * Provides an API to the ui that wraps calls to the worker etc with promises.\n */\nimport * as Comlink from 'comlink'\nimport { WorkerCalculateMethod, MainThreadCalculateMethod } from './types'\nimport Untracker from './Untracker'\n\n/**\n * A proxy (via comlink) to an off thread calculation method.\n */\nlet proxy: Comlink.Remote<WorkerCalculateMethod> | undefined\n\nconst init = (async () => {\n  const Worker = (await import('worker-loader!./sort.worker.ts')).default\n  const worker = new Worker()\n  proxy = Comlink.wrap<WorkerCalculateMethod>(worker)\n})()\n\nconst calculate: MainThreadCalculateMethod = async (\n  type: 'sort' | 'unsort',\n  name: string,\n  valuesToSort: number[],\n  valuesToTrack: number[]\n) => {\n  // Wait until the worker is initialised.\n  await init\n\n  console.log(`Main Thread: Deploying ${type}: ${name}`)\n\n  const [buffer, numMoves, calculatedValues] = await (proxy as Comlink.Remote<\n    WorkerCalculateMethod\n  >)(type, name, valuesToSort)\n\n  console.log(`Main Thread: Received ${type} data: ${name}`)\n\n  return [new Untracker(buffer, numMoves, valuesToTrack), calculatedValues]\n}\n\nexport default calculate\n","import React, { useCallback } from 'react'\nimport useCanvas, { DrawingMethod } from 'react-hooks-use-drawing-canvas'\nimport { MoveType, Move } from '../../sort/types'\nimport Untracker from '../../sort/Untracker'\nimport './Display.scss'\n\n/** continuously displays values on the screen */\nconst Display: React.FC<{\n  values: number[]\n  moveRef: React.MutableRefObject<Move | undefined>\n  untracker?: Untracker\n}> = props => {\n  const { values, moveRef, untracker } = props\n\n  const draw = useCallback<DrawingMethod>(\n    ctx => {\n      // resize the pixels, not just a maths transform\n      ctx.canvas.width = ctx.canvas.height = values.length\n      ctx.setTransform(1, 0, 0, -1, 0, values.length)\n\n      ctx.fillStyle = 'rgb(87,163,207)'\n\n      const currentValues = [...values]\n      values.forEach((value, index) => {\n        ctx.fillRect(index, 0, 1, value)\n      })\n\n      const drawMove = () => {\n        const move = moveRef.current\n        if (!move) return\n        switch (move.type) {\n          case MoveType.SWAP: {\n            const { i, j } = move\n            ctx.save()\n            ctx.fillStyle = 'cyan'\n            ctx.fillRect(i.index, 0, 1, j.value)\n            ctx.fillRect(j.index, 0, 1, i.value)\n            ctx.restore()\n\n            // We make sure that the values are repainted on the next frame by\n            // setting the current value to NaN.\n            currentValues[i.index] = currentValues[j.index] = NaN\n            break\n          }\n          case MoveType.COMPARE: {\n            const { i, j, result } = move\n\n            const color = ['lime', 'orange', 'red']\n            ctx.save()\n            ctx.fillStyle = color[1 + result]\n            ctx.fillRect(i.index, 0, 1, i.value)\n\n            ctx.fillStyle = color[1 - result]\n            ctx.fillRect(j.index, 0, 1, j.value)\n            ctx.restore()\n\n            currentValues[i.index] = currentValues[j.index] = NaN\n            break\n          }\n          case MoveType.MEMCPY: {\n            const { from, to, value } = move\n\n            ctx.save()\n            ctx.fillStyle = 'gold'\n            ctx.fillRect(from.index, 0, 1, value)\n            ctx.fillRect(to.index, 0, 1, value)\n            ctx.restore()\n\n            currentValues[from.index] = currentValues[to.index] = NaN\n            break\n          }\n          case MoveType.NTH_BIT_SET: {\n            const {\n              index: { index },\n              result\n            } = move\n\n            ctx.save()\n            ctx.fillStyle = 'black'\n            ctx.fillRect(\n              index + 0.1,\n              result ? Math.floor(values.length / 2) : 0,\n              0.8,\n              Math.floor(values.length / 2)\n            )\n            ctx.restore()\n\n            currentValues[index] = NaN\n            break\n          }\n        }\n      }\n\n      let frame: number\n      const drawFrame = () => {\n        frame = requestAnimationFrame(drawFrame)\n        // check the main values\n        for (let i = 0; i < values.length; i++) {\n          if (currentValues[i] !== values[i]) {\n            ctx.clearRect(i, 0, 1, values.length)\n            ctx.fillRect(i, 0, 1, values[i])\n            currentValues[i] = values[i]\n          }\n        }\n\n        // then the extra memory\n        untracker?.forEachInExtra((_buffer, index, value) => {\n          ctx.save()\n          ctx.globalAlpha = 0.2\n          ctx.fillStyle = 'purple'\n\n          ctx.fillRect(index, 0, 1, value)\n          // repaint the extra values each time\n          currentValues[index] = NaN\n\n          ctx.restore()\n        })\n\n        drawMove()\n      }\n\n      drawFrame()\n\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    },\n    [values, moveRef, untracker]\n  )\n\n  const canvasRef = useCanvas(draw)\n\n  return <canvas className=\"Display\" ref={canvasRef} />\n}\n\nexport default Display\n","import React, { useRef, useEffect } from 'react'\nimport { IconType } from 'react-icons/lib/cjs'\nimport './Button.scss'\n\ntype ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n  name: string\n  handler: () => void\n  disabled?: boolean\n  keyStr?: string\n  keyCode?: number\n}\n\nconst Button: React.FC<ButtonProps> = ({\n  name,\n  handler,\n  disabled,\n  keyStr,\n  keyCode,\n  children,\n  className,\n  ...buttonAttributes\n}) => {\n  const camelCaseName = name\n    .replace(/^(.)/, (_x, y) => y.toLowerCase())\n    .replace(/ (.)/g, (_x, y) => y.toUpperCase())\n\n  // We want to make it possible to specify a keyboard event that will also fire\n  // the button.\n  const ref = useRef<HTMLButtonElement>(null)\n  useEffect(() => {\n    if (keyStr !== undefined || keyCode !== undefined) {\n      const listener = (e: KeyboardEvent) => {\n        // By clicking the button instead of calling the callback, we make sure\n        // that the callback is not fired if the button is disabled\n        if (e.key === keyStr || e.keyCode === keyCode) {\n          ref.current?.click()\n          if (e.key === ' ') e.preventDefault()\n        }\n      }\n      window.addEventListener('keydown', listener)\n      return () => {\n        window.removeEventListener('keydown', listener)\n      }\n    }\n  }, [ref, keyStr, keyCode])\n\n  return (\n    <button\n      ref={ref}\n      className={`Button ${className} ${camelCaseName}`}\n      title={name}\n      onClick={handler}\n      disabled={disabled}\n      {...buttonAttributes}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport const IconButton: React.FC<ButtonProps & { Icon: IconType }> = ({\n  Icon,\n  ...props\n}) => (\n  <Button {...props} className={`${props.className} Icon`}>\n    <Icon className=\"icon\" />\n  </Button>\n)\n\nexport default Button\n","import React, { useState } from 'react'\nimport {\n  FaRedoAlt,\n  FaBackward,\n  FaStepBackward,\n  FaPlay,\n  FaSyncAlt,\n  FaForward,\n  FaStepForward,\n  FaEllipsisV,\n  FaPlus,\n  FaMinus,\n  FaPause,\n  FaInfo\n} from 'react-icons/fa'\nimport Button, { IconButton } from './Button'\nimport './Menu.scss'\n\ninterface ButtonProps {\n  handler: () => void\n  keyStr?: string\n  keyCode?: number\n  disabled?: boolean\n}\n\nconst Menu: React.FC<{\n  reverse: ButtonProps & { status: boolean }\n  restart: ButtonProps\n  speedDown: ButtonProps\n  stepBack: ButtonProps\n  play: ButtonProps & { status: boolean }\n  stepForward: ButtonProps\n  speedUp: ButtonProps\n  stats: ButtonProps\n  sizeUp: ButtonProps\n  sizeDown: ButtonProps\n  unsort: {\n    disabled: boolean\n    list: string[]\n    handler(key: string): void\n  }\n  sort: {\n    current: string\n    list: string[]\n    handler(key: string): void\n  }\n}> = ({\n  reverse: { status: reverseStatus, ...reverse },\n  restart,\n  speedDown,\n  stepBack,\n  play: { status: playStatus, ...play },\n  stepForward,\n  speedUp,\n  stats,\n  sizeUp,\n  sizeDown,\n  unsort,\n  sort\n}) => {\n  const [spinning, setSpinning] = useState(false)\n  const [extra, setExtra] = useState(false)\n\n  return (\n    <div className=\"Menu\">\n      <IconButton\n        name=\"restart\"\n        Icon={FaRedoAlt}\n        style={\n          spinning\n            ? {\n                transition: 'transform 300ms',\n                transform: `rotate(${360}deg)`\n              }\n            : {}\n        }\n        onTransitionEnd={() => setSpinning(false)}\n        {...restart}\n        handler={() => {\n          restart.handler()\n          setSpinning(true)\n        }}\n      />\n      <IconButton name=\"speed down\" Icon={FaBackward} {...speedDown} />\n      <IconButton name=\"step back\" Icon={FaStepBackward} {...stepBack} />\n      <div className=\"playPauseWithReverse\">\n        <IconButton\n          name=\"play\"\n          Icon={playStatus ? FaPause : FaPlay}\n          style={{\n            transition: 'transform 100ms',\n            transform: `rotate(${reverseStatus ? 180 : 0}deg)`\n          }}\n          {...play}\n        />\n        <IconButton name=\"reverse\" Icon={FaSyncAlt} {...reverse} />\n      </div>\n      <IconButton name=\"step forward\" Icon={FaStepForward} {...stepForward} />\n      <IconButton name=\"speed up\" Icon={FaForward} {...speedUp} />\n      <div className={`extra ${extra ? 'show' : 'hide'}`}>\n        <IconButton\n          name=\"extra options\"\n          Icon={FaEllipsisV}\n          keyCode={27}\n          handler={() => setExtra(!extra)}\n        />\n        <div className=\"buttons\">\n          <div className=\"algorithms\">\n            <div className=\"unsort\">\n              {unsort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    unsort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  disabled={unsort.disabled}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n            <div className=\"sort\">\n              {sort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    setExtra(false)\n                    sort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  className={sort.current === camelCase ? 'active' : ''}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n          </div>\n          <IconButton name=\"show stats\" Icon={FaInfo} {...stats} />\n          <IconButton name=\"size up\" Icon={FaPlus} {...sizeUp} />\n          <IconButton name=\"size down\" Icon={FaMinus} {...sizeDown} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default Menu\n","import { useMemo } from 'react'\n\n/**\n * Supplies a sorted array containing the integers from 1 to size.\n *\n * The array reference will change when the size changes.\n */\nconst useValues = (size: number) => {\n  return useMemo(() => {\n    const values = []\n\n    for (let i = 1; i <= size; i++) values.push(i)\n\n    return values\n  }, [size])\n}\n\nexport default useValues\n","import { Move, MoveType } from './types'\n\nexport default class StatTracker {\n  comparisons = 0\n  reads = 0\n  writes = 0\n\n  private modifyBy(move: Move, multiplier: number) {\n    switch (move.type) {\n      case MoveType.COMPARE:\n        this.reads += 2 * multiplier\n        this.comparisons += 1 * multiplier\n        break\n      case MoveType.SWAP:\n        this.reads += 2 * multiplier\n        this.writes += 2 * multiplier\n        break\n      case MoveType.MALLOC:\n        break\n      case MoveType.MEMCPY:\n        this.reads += 1 * multiplier\n        this.writes += 1 * multiplier\n        break\n      case MoveType.FREE:\n        break\n      case MoveType.NTH_BIT_SET:\n        this.reads += 1 * multiplier\n        break\n    }\n  }\n\n  add(move: Move) {\n    this.modifyBy(move, 1)\n  }\n\n  subtract(move: Move) {\n    this.modifyBy(move, -1)\n  }\n}\n","import { Move, MoveType } from './types'\n\n/**\n * The number of bytes that represent each move.\n *\n * The most space needed for a move is on a compare move, which containse 7\n * different numbers. These numbers can each fit in 32 bits, and the type can\n * fit in 8 bits.\n */\nexport const BYTES_PER_MOVE = 26\n\n/**\n * Provides the bility to take a `Move` object and encode it as a sequence of\n * numbers, to add to the\n *\n * @param move The move to be encoded.\n * @param buffer The ArrayBuffer representing all of the moves.\n * @param idx The index to insert into the list of moves at. (Not the number of\n * bytes)\n */\nexport const encodeMove = (move: Move, buffer: ArrayBuffer, idx: number) => {\n  const offset = idx * BYTES_PER_MOVE\n  const view = new DataView(buffer)\n  // We encode the type into the first byte.\n  view.setUint8(offset, move.type)\n\n  // Depending on the type, the encoding will be different.\n  switch (move.type) {\n    case MoveType.COMPARE:\n      // The only difference on a compare move is that we also encode the\n      // result of the compare. Therefore we encode them with the same code.\n      view.setUint32(offset + 1, move.i.buffer)\n      view.setUint32(offset + 5, move.i.index)\n      view.setUint32(offset + 9, move.i.value)\n      view.setUint32(offset + 13, move.j.buffer)\n      view.setUint32(offset + 17, move.j.index)\n      view.setUint32(offset + 21, move.j.value)\n      view.setInt8(offset + 25, move.result)\n      break\n    case MoveType.SWAP:\n      // Swap moves contain two indexes, consisting of a buffer id and an\n      // index in the buffer, plus the values at the indicies.\n      view.setUint32(offset + 1, move.i.buffer)\n      view.setUint32(offset + 5, move.i.index)\n      view.setUint32(offset + 9, move.i.value)\n      view.setUint32(offset + 13, move.j.buffer)\n      view.setUint32(offset + 17, move.j.index)\n      view.setUint32(offset + 21, move.j.value)\n      break\n    case MoveType.MALLOC:\n      // A malloc move stores the size and id of the buffer that was\n      // allocated.\n      view.setUint32(offset + 1, move.buffer)\n      view.setUint32(offset + 5, move.size)\n      break\n    case MoveType.MEMCPY:\n      view.setUint32(offset + 1, move.from.buffer)\n      view.setUint32(offset + 5, move.from.index)\n      view.setUint32(offset + 9, move.to.buffer)\n      view.setUint32(offset + 13, move.to.index)\n      view.setUint32(offset + 17, move.value)\n      view.setUint32(offset + 21, move.original)\n      break\n    case MoveType.FREE:\n      view.setUint32(offset + 1, move.buffer)\n      break\n    case MoveType.NTH_BIT_SET:\n      view.setUint32(offset + 1, move.index.buffer)\n      view.setUint32(offset + 5, move.index.index)\n      view.setUint8(offset + 9, move.result ? 1 : 0)\n      break\n  }\n}\n\n/**\n * Retrieves a move from an array buffer.\n *\n * @param buffer The buffer containing all of the moves.\n * @param idx The index of the move in the buffer.\n */\nexport const decodeMove = (buffer: ArrayBuffer, idx: number): Move => {\n  const offset = idx * BYTES_PER_MOVE\n  const view = new DataView(buffer)\n\n  const type = view.getUint8(offset) as MoveType\n\n  switch (type) {\n    case MoveType.COMPARE:\n      return {\n        type: MoveType.COMPARE,\n        i: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5),\n          value: view.getUint32(offset + 9)\n        },\n        j: {\n          buffer: view.getUint32(offset + 13),\n          index: view.getUint32(offset + 17),\n          value: view.getUint32(offset + 21)\n        },\n        result: view.getInt8(offset + 25)\n      }\n    case MoveType.SWAP:\n      return {\n        type: MoveType.SWAP,\n        i: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5),\n          value: view.getUint32(offset + 9)\n        },\n        j: {\n          buffer: view.getUint32(offset + 13),\n          index: view.getUint32(offset + 17),\n          value: view.getUint32(offset + 21)\n        }\n      }\n    case MoveType.MALLOC:\n      return {\n        type: MoveType.MALLOC,\n        buffer: view.getUint32(offset + 1),\n        size: view.getUint32(offset + 5)\n      }\n    case MoveType.MEMCPY:\n      return {\n        type: MoveType.MEMCPY,\n        from: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5)\n        },\n        to: {\n          buffer: view.getUint32(offset + 9),\n          index: view.getUint32(offset + 13)\n        },\n        value: view.getUint32(offset + 17),\n        original: view.getUint32(offset + 21)\n      }\n    case MoveType.FREE:\n      return {\n        type: MoveType.FREE,\n        buffer: view.getUint32(offset + 1)\n      }\n    case MoveType.NTH_BIT_SET:\n      return {\n        type: MoveType.NTH_BIT_SET,\n        index: {\n          buffer: view.getUint32(offset + 1),\n          index: view.getUint32(offset + 5)\n        },\n        result: view.getUint8(offset + 9) !== 0\n      }\n  }\n}\n\n/**\n * A wrapper for an `ArrayBuffer` that represents the different moves in a sort.\n *\n * An `ArrayBuffer` is preferable to a list of `Move` objects as it is\n * transferable between threads. An `ArrayBuffer` is however more difficult to\n * work with than a normal javascript `Array`, as it does not have any `push` or\n * `pop` methods.\n *\n * This class effectively implements a push method for an underlying array\n * buffer that can then be unwrapped when transfering between threads.\n */\nexport class TransferableMovesBuilder {\n  /**\n   * The buffer containing the encoded moves.\n   */\n  buffer: ArrayBuffer\n  /**\n   * The number of encoded moves in the buffer.\n   */\n  private size: number\n\n  constructor() {\n    this.size = 0\n    this.buffer = new ArrayBuffer(256 * BYTES_PER_MOVE)\n  }\n\n  /**\n   * Checks if there is enough space available in the current buffer for more\n   * moves. If not doubles the allocated space and copies the previous values.\n   *\n   * The doubling allows the time complexity of adding a move to amortise to\n   * O(1).\n   */\n  private growIfNeeded() {\n    if ((this.size + 1) * BYTES_PER_MOVE <= this.buffer.byteLength) {\n      return\n    }\n    // We need more space.\n\n    // Allocate a new buffer.\n    const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2)\n    const oldView = new DataView(this.buffer)\n    const newView = new DataView(newBuffer)\n\n    // Copy the previous bytes.\n    for (let i = 0; i < this.buffer.byteLength; i++) {\n      newView.setUint8(i, oldView.getUint8(i))\n    }\n\n    // Replace the buffer.\n    this.buffer = newBuffer\n  }\n\n  /**\n   * Encodes a `Move` object and adds it to the buffer.\n   *\n   * @param move The move to be encoded.\n   */\n  addMove(move: Move) {\n    // We want to add the encoded move to the array buffer\n    this.growIfNeeded()\n    encodeMove(move, this.buffer, this.size)\n    this.size += 1\n  }\n\n  get length() {\n    return this.size\n  }\n}\n","import { MoveType, Move, Direction } from './types'\nimport StatTracker from './StatTracker'\nimport { decodeMove } from './TransferableMovesList'\n\n/**\n * Just as the Tracker class is for recording the algorithms. The UnTracker is\n * for replaying a tracker.\n */\nexport default class Untracker {\n  private original: number[]\n  private buffers: {\n    [key: number]: number[]\n  }\n  private bufferIds: Set<number>\n  private moves: ArrayBuffer\n  private numMoves: number\n  private currentMove: number\n  statistics: StatTracker\n\n  constructor(moves: ArrayBuffer, numMoves: number, values: number[]) {\n    this.moves = moves\n    this.numMoves = numMoves\n    this.buffers = {\n      0: values\n    }\n    this.bufferIds = new Set()\n    this.original = [...values]\n\n    this.currentMove = 0\n\n    this.statistics = new StatTracker()\n\n    this.hasNext = this.hasNext.bind(this)\n    this.hasPrevious = this.hasPrevious.bind(this)\n    this.next = this.next.bind(this)\n    this.previous = this.previous.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  /** Returns true if there is a future move available to do. */\n  private hasNext() {\n    return this.currentMove < this.numMoves\n  }\n\n  /** Returns true if there is a previous move available to undo. */\n  private hasPrevious() {\n    return this.currentMove > 0\n  }\n\n  next() {\n    if (!this.hasNext()) return\n\n    const move = decodeMove(this.moves, this.currentMove++)\n\n    this.statistics.add(move)\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = j.value\n          this.buffers[j.buffer][j.index] = i.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n          this.buffers[buffer] = []\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const { from, to } = move\n\n          const value = this.buffers[from.buffer][from.index]\n          this.buffers[to.buffer][to.index] = value\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  previous() {\n    if (!this.hasPrevious()) return\n\n    const move = decodeMove(this.moves, --this.currentMove)\n\n    this.statistics.subtract(move)\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = i.value\n          this.buffers[j.buffer][j.index] = j.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const {\n            to: { buffer, index },\n            original\n          } = move\n\n          this.buffers[buffer][index] = original\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  /** Returns the values array to its original state. */\n  reset() {\n    // delete the extra buffers\n    this.bufferIds.forEach(id => {\n      delete this.buffers[id]\n    })\n\n    for (let i = 0; i < this.original.length; i++) {\n      this.buffers[0][i] = this.original[i]\n    }\n\n    this.currentMove = 0\n  }\n\n  /** Advances the untracker in a direction determined by the reverse boolean */\n  step(direction: Direction) {\n    return direction === Direction.FORWARD ? this.next() : this.previous()\n  }\n\n  /**\n   * Returns true if the untracker has a valid move available in the determined\n   * direction\n   */\n  hasStep(direction: Direction) {\n    return direction === Direction.FORWARD ? this.hasNext() : this.hasPrevious()\n  }\n\n  /**\n   * Animates the advancement of steps in a given direction.\n   *\n   * @param stepsPerFrame The number of steps to be advanced per frame\n   * @param onCompletion A callback to be run if all of the steps have been\n   * completed.\n   */\n  animateStepsPerFrame(\n    stepsPerFrame: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const { onCompletion, moveRef } = options\n\n    const base = (stepsPerFrame: number) => {\n      for (let i = 0; i < stepsPerFrame; i++) this.step(direction)\n    }\n\n    // if the moveRef is defined then record the last move\n    const withRecord = moveRef\n      ? () => {\n          base(stepsPerFrame - 1)\n          moveRef.current = this.step(direction)\n        }\n      : () => base(stepsPerFrame)\n\n    const withAnimationFrame = () => {\n      let frame: number\n      const run = () => {\n        withRecord()\n        if (this.hasStep(direction)) frame = requestAnimationFrame(run)\n        else if (onCompletion) onCompletion()\n      }\n      run()\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    }\n    const withInterval = () => {\n      const interval = setInterval(() => {\n        withRecord()\n        if (!this.hasStep(direction)) {\n          clearInterval(interval)\n          if (onCompletion) onCompletion()\n        }\n      }, 1 / (0.06 * stepsPerFrame))\n      return () => {\n        clearInterval(interval)\n      }\n    }\n\n    return stepsPerFrame >= 1 ? withAnimationFrame() : withInterval()\n  }\n\n  animateUntilCompletion(\n    timeUntilCompletion: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const stepsRemaining =\n      direction === Direction.FORWARD\n        ? this.numMoves - this.currentMove\n        : this.currentMove\n\n    // there are 0.06 frames per millisecond\n    const stepsPerFrame = stepsRemaining / (timeUntilCompletion * 0.06)\n\n    return this.animateStepsPerFrame(stepsPerFrame, direction, options)\n  }\n\n  forEachInExtra(\n    callback: (buffer: number, index: number, value: number) => void\n  ) {\n    this.bufferIds.forEach(buffer => {\n      this.buffers[buffer].forEach((value, index) =>\n        callback(buffer, index, value)\n      )\n    })\n  }\n}\n","import { useState, useCallback, useEffect } from 'react'\nimport Untracker from '../../sort/Untracker'\nimport { Direction } from '../../sort/types'\nimport calculate from '../../sort'\n\nconst useAlgorithms = (values: number[]) => {\n  /**\n   * The state of the unsorted values before they have been sorted.\n   *\n   * By keeping track of these values, we can calculate the sort on the unsorted\n   * values before the unsort has finished animating.\n   */\n  const [unsortedValues, setUnsortedValues] = useState([...values])\n  useEffect(() => setUnsortedValues([...values]), [values])\n\n  const unsortWith = useCallback(\n    async (name: string, block?: () => void, unblock?: () => void) => {\n      if (name === 'nothing') {\n        setUnsortedValues([...values])\n        return\n      }\n      if (block && unblock) block()\n\n      return calculate('unsort', name, values, values).then(\n        ([untracker, unsortedValues]) => {\n          setUnsortedValues(unsortedValues)\n\n          untracker.animateUntilCompletion(500, Direction.FORWARD, {\n            onCompletion: () => {\n              if (unblock) unblock()\n            }\n          })\n        }\n      )\n    },\n    [values]\n  )\n\n  /** A string identifying the currently in use sort. */\n  const [sortString, setSortString] = useState('heapSort')\n\n  /** The untracker for the sort */\n  const [sortUntracker, setSortUntracker] = useState<Untracker>()\n\n  useEffect(() => {\n    let invalid = false\n\n    calculate('sort', sortString, unsortedValues, values)\n      .then(([untracker]) => !invalid && setSortUntracker(untracker))\n      .catch(console.error)\n\n    return () => {\n      invalid = true\n    }\n  }, [sortString, unsortedValues, values])\n\n  const setSort = useCallback((name: string) => {\n    setSortString(name)\n  }, [])\n\n  return {\n    unsortWith,\n    sort: sortUntracker,\n    setSort,\n    sortString\n  }\n}\n\nexport default useAlgorithms\n","import { useState, useCallback } from 'react'\n\n/** Toggles between two values */\nfunction useToggle<T>(first: T, second: T): [T, (set?: T) => void] {\n  const [value, setValue] = useState(true)\n  const toggle = useCallback(\n    (firstOrSecond?: T) => {\n      if (firstOrSecond === first) setValue(true)\n      else if (firstOrSecond === second) setValue(false)\n      else setValue(value => !value)\n    },\n    [first, second]\n  )\n\n  return [value ? first : second, toggle]\n}\n\nexport default useToggle\n","import { useState, useCallback, useMemo } from 'react'\n\nconst useBlock = () => {\n  const [count, setCount] = useState(0)\n\n  const blocking = count > 0\n  const block = useCallback(() => {\n    setCount(count => count + 1)\n  }, [])\n\n  const unblock = useCallback(() => {\n    setCount(count => Math.max(0, count - 1))\n  }, [])\n\n  return useMemo(() => ({ blocking, block, unblock }), [\n    blocking,\n    block,\n    unblock\n  ])\n}\n\nexport default useBlock\n","import { Algorithm } from '../../types'\nimport binaryInsertionSort from './binary-insertion-sort'\nimport bubbleSort from './bubble-sort'\nimport heapSort from './heap-sort'\nimport mergeSort from './merge-sort'\n// import pancakeSort from './pancake-sort'\nimport quickSort from './quick-sort'\nimport radixSortLsb from './radix-sort-lsb'\nimport radixSortMsb from './radix-sort-msb'\nimport shellSort from './shell-sort'\nimport timsort from './tim-sort'\n\nexport const algorithms: { [key: string]: Algorithm } = {\n  binaryInsertionSort,\n  bubbleSort,\n  heapSort,\n  mergeSort,\n  // pancakeSort,\n  quickSort,\n  radixSortLsb,\n  radixSortMsb,\n  shellSort,\n  timsort\n}\n\n/**\n * Strings representing the names of the implemented algorithms.\n */\n// I would like to implement the names with something like this:\n//\n// `export const algorithmNames = Object.keys(algorithms)`\n//\n// However, Tree shaking would then include the algotithms object to retrieve\n// the keys. This will bloat the main package and is sub optimal, so I have\n// resorted to just writing them here.\nexport const algorithmNames = [\n  'binaryInsertionSort',\n  'bubbleSort',\n  'heapSort',\n  'mergeSort',\n  // 'pancakeSort',\n  'quickSort',\n  'radixSortLsb',\n  'radixSortMsb',\n  'shellSort',\n  'timsort'\n]\n","import { Algorithm } from '../../types'\nimport cut from './cut'\nimport hinduShuffle from './hindu-shuffle'\nimport overhandShuffle from './overhand-shuffle'\nimport perfectRiffleShuffle from './perfect-riffle-shuffle'\nimport randomise from './randomise'\nimport reverse from './reverse'\nimport riffleShuffle from './riffle-shuffle'\n\nexport const algorithms: { [key: string]: Algorithm } = {\n  cut,\n  hinduShuffle,\n  overhandShuffle,\n  perfectRiffleShuffle,\n  randomise,\n  reverse,\n  riffleShuffle\n}\n\n/**\n * Strings representing the currently implemented unsorting algorithms.\n */\n// see `../sort/index.ts`.\nexport const algorithmNames = [\n  'cut',\n  'hinduShuffle',\n  'overhandShuffle',\n  'perfectRiffleShuffle',\n  'randomise',\n  'reverse',\n  'riffleShuffle'\n]\n","import React, { useEffect, useState } from 'react'\nimport StatTracker from '../../sort/StatTracker'\nimport './Stats.scss'\n\nconst Stats: React.FC<{\n  stats?: StatTracker\n  display: boolean\n}> = ({ stats = { comparisons: 0, reads: 0, writes: 0 }, display }) => {\n  const [comparisons, setComparisons] = useState(stats.comparisons)\n  const [reads, setReads] = useState(stats.reads)\n  const [writes, setWrites] = useState(stats.writes)\n\n  /** update the values if they have changed  */\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setComparisons(stats.comparisons)\n      setReads(stats.reads)\n      setWrites(stats.writes)\n    }, 50)\n    return () => clearInterval(interval)\n  }, [stats])\n\n  return (\n    <div className={`Stats ${display ? 'show' : 'hide'}`}>\n      <div className=\"stat comparisons\">Comparisons: {comparisons}</div>\n      <div className=\"stat reads\">Reads: {reads}</div>\n      <div className=\"stat writes\">Writes: {writes}</div>\n    </div>\n  )\n}\n\nexport default Stats\n","import React, { useState, useEffect, useRef } from 'react'\nimport Display from './components/Display'\nimport Menu from './components/Menu'\nimport useValues from './hooks/use-values'\nimport useAlgorithms from './hooks/use-algorithms'\nimport useToggle from './hooks/use-toggle'\nimport useBlock from './hooks/use-block'\nimport { algorithmNames as sortNames } from '../sort/algorithms/sort'\nimport { algorithmNames as unsortNames } from '../sort/algorithms/unsort'\nimport { Direction, Move } from '../sort/types'\nimport './App.scss'\nimport Stats from './components/Stats'\n\nconst App: React.FC = () => {\n  const [direction, changeDirection] = useToggle(\n    Direction.FORWARD,\n    Direction.BACKWARD\n  )\n  const [play, setPlay] = useState(false)\n  const [displayStats, setDisplayStats] = useState(false)\n  const { blocking, block, unblock } = useBlock()\n\n  /** The number of steps per frame is exponential in speed */\n  const minSpeed = -10\n  const maxSpeed = 10\n  const [speed, setSpeed] = useState(-4)\n\n  /** The length of the values array is exponantial in size */\n  const minSize = 3\n  const maxSize = 20\n  const [size, setSize] = useState(12)\n\n  const values = useValues(Math.floor(Math.pow(1.5, size)))\n\n  const { unsortWith, sort, setSort, sortString } = useAlgorithms(values)\n\n  const moveRef = useRef<Move | undefined>()\n  useEffect(() => {\n    moveRef.current = undefined\n    // Any blocking action occurring will refresh the current move.\n  }, [moveRef, blocking])\n\n  useEffect(() => {\n    if (play) {\n      return sort?.animateStepsPerFrame(Math.pow(1.3, speed), direction, {\n        onCompletion: () => {\n          setPlay(false)\n          changeDirection()\n          moveRef.current = undefined\n        },\n        moveRef\n      })\n    }\n  }, [play, sort, speed, direction, changeDirection, moveRef])\n\n  // Try to prevent screen lock with the Screen WakeLock API\n  useEffect(() => {\n    let lock: WakeLockSentinel | null = null\n    let cleaned = false\n\n    if (play) {\n      navigator.wakeLock?.request('screen').then(sentinel => {\n        if (cleaned) {\n          sentinel.release()\n        } else {\n          lock = sentinel\n          console.log('obtained screen lock.')\n        }\n      })\n    }\n\n    return () => {\n      cleaned = true\n      if (lock) {\n        lock.release()\n        console.log('released screen lock.')\n      }\n    }\n  }, [play])\n\n  return (\n    <div className=\"App\">\n      <Menu\n        restart={{\n          disabled: blocking || !sort,\n          keyStr: 'r',\n          handler: () => {\n            changeDirection(Direction.FORWARD)\n            setPlay(false)\n            block()\n\n            sort?.animateUntilCompletion(1000, Direction.BACKWARD, {\n              onCompletion: () => unblock()\n            })\n          }\n        }}\n        speedDown={{\n          disabled: blocking || !sort,\n          // if playing leftArrow decreases speed\n          keyCode: play ? 37 : undefined,\n          handler: () => setSpeed(Math.max(minSpeed, speed - 1))\n        }}\n        stepBack={{\n          disabled: blocking || !sort,\n          // if not playing leftArrow steps back\n          keyCode: play ? undefined : 37,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.BACKWARD)\n          }\n        }}\n        play={{\n          disabled: blocking || !sort,\n          handler: () => setPlay(!play),\n          keyStr: ' ',\n          status: play\n        }}\n        reverse={{\n          disabled: blocking || !sort,\n          keyStr: '`',\n          handler: () => {\n            const oppositeDirection =\n              direction === Direction.BACKWARD\n                ? Direction.FORWARD\n                : Direction.BACKWARD\n            if (sort?.hasStep(oppositeDirection)) changeDirection()\n          },\n          status: direction === Direction.BACKWARD\n        }}\n        stepForward={{\n          disabled: blocking || !sort,\n          // if not playing rightArrow steps forward\n          keyCode: play ? undefined : 39,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.FORWARD)\n          }\n        }}\n        speedUp={{\n          disabled: blocking || !sort,\n          // if playing rightArrow increases speed\n          keyCode: play ? 39 : undefined,\n          handler: () => setSpeed(Math.min(maxSpeed, speed + 1))\n        }}\n        stats={{\n          keyStr: 's',\n          handler: () => setDisplayStats(v => !v)\n        }}\n        sizeUp={{\n          keyCode: 38,\n          handler: () => setSize(Math.min(maxSize, size + 1))\n        }}\n        sizeDown={{\n          keyCode: 40,\n          handler: () => setSize(Math.max(minSize, size - 1))\n        }}\n        unsort={{\n          disabled: blocking,\n          list: unsortNames,\n          handler: algorithm => {\n            if (unsortNames.includes(algorithm)) {\n              setPlay(false)\n              changeDirection(Direction.FORWARD)\n\n              unsortWith(algorithm, block, unblock)\n            }\n          }\n        }}\n        sort={{\n          current: sortString,\n          list: sortNames,\n          handler: algorithm => {\n            if (algorithm !== sortString) {\n              moveRef.current = undefined\n              unsortWith('nothing').then(() => setSort(algorithm))\n            }\n          }\n        }}\n      />\n      <Stats stats={sort?.statistics} display={displayStats} />\n      <Display values={values} moveRef={moveRef} untracker={sort} />\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './ui/App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}