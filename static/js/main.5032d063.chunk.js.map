{"version":3,"sources":["sort/types.ts","ui/components/Display.tsx","ui/components/Button.tsx","ui/components/Menu.tsx","ui/hooks/use-values.ts","sort/algorithms/unsort/common.ts","sort/algorithms/unsort/index.ts","sort/algorithms/unsort/cut.ts","sort/algorithms/unsort/hindu-shuffle.ts","sort/algorithms/unsort/overhand-shuffle.ts","sort/algorithms/unsort/perfect-riffle-shuffle.ts","sort/algorithms/unsort/randomise.ts","sort/algorithms/unsort/reverse.ts","sort/algorithms/unsort/riffle-shuffle.ts","sort/algorithms/sort/binary-insertion-sort.ts","sort/algorithms/sort/bubble-sort.ts","sort/algorithms/sort/heap-sort.ts","sort/algorithms/sort/merge-sort.ts","sort/algorithms/sort/quick-sort.ts","sort/algorithms/sort/radix-sort-lsb.ts","sort/algorithms/sort/radix-sort-msb.ts","sort/algorithms/sort/shell-sort.ts","sort/algorithms/sort/tim-sort.ts","sort/algorithms/sort/index.ts","sort/StatTracker.ts","sort/Untracker.ts","sort/Tracker.ts","ui/hooks/use-algorithms.ts","ui/hooks/use-toggle.ts","ui/hooks/use-block.ts","ui/components/Stats.tsx","ui/App.tsx","index.tsx"],"names":["MoveType","Direction","Display","props","values","moveRef","untracker","draw","useCallback","ctx","canvas","width","height","length","setTransform","fillStyle","currentValues","forEach","value","index","fillRect","frame","drawFrame","requestAnimationFrame","i","clearRect","forEachInExtra","_buffer","save","globalAlpha","NaN","restore","move","current","type","SWAP","j","COMPARE","result","color","MEMCPY","from","to","NTH_BIT_SET","drawMove","cancelAnimationFrame","canvasRef","useCanvas","className","ref","Button","name","handler","disabled","keyStr","keyCode","children","buttonAttributes","camelCaseName","replace","_x","y","toLowerCase","toUpperCase","useRef","useEffect","undefined","listener","e","key","click","preventDefault","window","addEventListener","removeEventListener","title","onClick","IconButton","Icon","Menu","reverse","reverseStatus","status","restart","speedDown","stepBack","play","playStatus","stepForward","speedUp","stats","sizeUp","sizeDown","unsort","sort","useState","spinning","setSpinning","extra","setExtra","FaRedoAlt","style","transition","transform","onTransitionEnd","FaBackward","FaStepBackward","FaPause","FaPlay","FaSyncAlt","FaStepForward","FaForward","FaEllipsisV","list","map","camelCase","FaInfo","FaPlus","FaMinus","useValues","size","useMemo","push","randomNormal","mean","stddev","u","v","Math","random","normal","sqrt","log","cos","PI","boundAndRound","min","target","max","round","algorithms","cut","malloc","memcpy","free","split","buffer","hinduShuffle","group","start","overhandShuffle","processed","perfectRiffleShuffle","halfSize","firstHalf","secondHalf","destination","randomise","swap","floor","riffleShuffle","pA","pB","dest","binaryInsertionSort","compare","findIndex","low","high","mid","bubbleSort","heapSort","heapify","extreme","left","right","mergeSort","k","merge","quickSort","pivot","partition","lsbRadixSort","nthBitSet","needle","zeroIndex","oneIndex","msbRadixSort","loStack","hiStack","needleStack","ceil","log2","lo","pop","hi","zero","one","shellSort","gap","MergeState","pending","minGallop","radixSortLsb","radixSortMsb","timsort","countRun","n","gallopLeft","mark","hint","fromBuffer","indexFrom","base","lastOffset","offset","maxOffset","temp","gallopRight","binarySearch","shift","insertionSort","mergeLo","mergeState","nA","nB","countA","countB","gallop","mergeHi","mergeAt","len","splice","ignoreAtFront","mergeCollapse","remaining","MIN_RUN","r","calculateMinRun","mergeForceCollapse","StatTracker","comparisons","reads","writes","multiplier","this","MALLOC","FREE","modifyBy","Untracker","moves","original","buffers","bufferIds","currentMove","statistics","0","Set","hasNext","bind","hasPrevious","next","previous","reset","add","delete","subtract","id","direction","FORWARD","stepsPerFrame","options","onCompletion","step","withRecord","withAnimationFrame","run","hasStep","withInterval","interval","setInterval","clearInterval","timeUntilCompletion","stepsRemaining","animateStepsPerFrame","callback","Symbol","iterator","BufferIdPool","_next","_inUse","has","Tracker","bufferIdPool","iIndex","jIndex","normaliseIndex","iBuffer","jBuffer","sign","Array","givenIndex","Boolean","useAlgorithms","unsortedValues","setUnsortedValues","unsortWith","block","unblock","unsortingAlgorithms","copy","tracker","untrack","animateUntilCompletion","sortString","setSortString","sortUntracker","setSortUntracker","invalid","a","sortingAlgorithms","calculate","then","setSort","useToggle","first","second","setValue","toggle","firstOrSecond","useBlock","count","setCount","blocking","Stats","display","setComparisons","setReads","setWrites","App","BACKWARD","changeDirection","setPlay","displayStats","setDisplayStats","speed","setSpeed","setSize","pow","oppositeDirection","Object","keys","algorithm","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5032d063.chunk.js","sourcesContent":["import Tracker from './Tracker'\n\n/** The type that each sorting algorithm should implement */\nexport type Algorithm = (tracker: Tracker) => void\n\n/** The different types of moves an algorithm can use */\nexport enum MoveType {\n  SWAP = 'SWAP',\n  COMPARE = 'COMPARE',\n  MALLOC = 'MALLOC',\n  MEMCPY = 'MEMCPY',\n  FREE = 'FREE',\n  NTH_BIT_SET = 'NTH_BIT_SET'\n}\n\n/**\n * Represents an index in an allocated buffer.\n */\nexport type Index = { buffer: number; index: number }\n\nexport interface SwapMove {\n  type: MoveType.SWAP\n  i: Index & { value: number }\n  j: Index & { value: number }\n}\n\nexport interface CompareMove {\n  type: MoveType.COMPARE\n  i: Index & { value: number }\n  j: Index & { value: number }\n  result: number\n}\n\nexport interface MallocMove {\n  type: MoveType.MALLOC\n  size: number\n  buffer: number\n}\n\nexport interface MemcpyMove {\n  type: MoveType.MEMCPY\n  from: Index\n  to: Index\n  value: number\n  original: number\n}\n\nexport interface FreeMove {\n  type: MoveType.FREE\n  buffer: number\n}\n\nexport interface NthBitSetMove {\n  type: MoveType.NTH_BIT_SET\n  index: Index\n  result: boolean\n}\n\nexport type Move =\n  | SwapMove\n  | CompareMove\n  | MallocMove\n  | MemcpyMove\n  | FreeMove\n  | NthBitSetMove\n\n/** Represents the direction of flow of an algorithm */\nexport enum Direction {\n  FORWARD = 'FORWARD',\n  BACKWARD = 'BACKWARD'\n}\n","import React, { useCallback } from 'react'\nimport useCanvas, { DrawingMethod } from 'react-hooks-use-drawing-canvas'\nimport { MoveType, Move } from '../../sort/types'\nimport Untracker from '../../sort/Untracker'\nimport './Display.scss'\n\n/** continuously displays values on the screen */\nconst Display: React.FC<{\n  values: number[]\n  moveRef: React.MutableRefObject<Move | undefined>\n  untracker?: Untracker\n}> = props => {\n  const { values, moveRef, untracker } = props\n\n  const draw = useCallback<DrawingMethod>(\n    ctx => {\n      // resize the pixels, not just a maths transform\n      ctx.canvas.width = ctx.canvas.height = values.length\n      ctx.setTransform(1, 0, 0, -1, 0, values.length)\n\n      ctx.fillStyle = 'rgb(87,163,207)'\n\n      const currentValues = [...values]\n      values.forEach((value, index) => {\n        ctx.fillRect(index, 0, 1, value)\n      })\n\n      const drawMove = () => {\n        const move = moveRef.current\n        if (!move) return\n        switch (move.type) {\n          case MoveType.SWAP: {\n            const { i, j } = move\n            ctx.save()\n            ctx.fillStyle = 'cyan'\n            ctx.fillRect(i.index, 0, 1, j.value)\n            ctx.fillRect(j.index, 0, 1, i.value)\n            ctx.restore()\n\n            // We make sure that the values are repainted on the next frame by\n            // setting the current value to NaN.\n            currentValues[i.index] = currentValues[j.index] = NaN\n            break\n          }\n          case MoveType.COMPARE: {\n            const { i, j, result } = move\n\n            const color = ['lime', 'orange', 'red']\n            ctx.save()\n            ctx.fillStyle = color[1 + result]\n            ctx.fillRect(i.index, 0, 1, i.value)\n\n            ctx.fillStyle = color[1 - result]\n            ctx.fillRect(j.index, 0, 1, j.value)\n            ctx.restore()\n\n            currentValues[i.index] = currentValues[j.index] = NaN\n            break\n          }\n          case MoveType.MEMCPY: {\n            const { from, to, value } = move\n\n            ctx.save()\n            ctx.fillStyle = 'gold'\n            ctx.fillRect(from.index, 0, 1, value)\n            ctx.fillRect(to.index, 0, 1, value)\n            ctx.restore()\n\n            currentValues[from.index] = currentValues[to.index] = NaN\n            break\n          }\n          case MoveType.NTH_BIT_SET: {\n            const {\n              index: { index },\n              result\n            } = move\n\n            ctx.save()\n            ctx.fillStyle = result ? 'white' : 'black'\n            ctx.fillRect(index + 0.1, 0, 0.8, values.length / 10)\n            ctx.restore()\n\n            currentValues[index] = NaN\n\n            break\n          }\n        }\n      }\n\n      let frame: number\n      const drawFrame = () => {\n        frame = requestAnimationFrame(drawFrame)\n        // check the main values\n        for (let i = 0; i < values.length; i++) {\n          if (currentValues[i] !== values[i]) {\n            ctx.clearRect(i, 0, 1, values.length)\n            ctx.fillRect(i, 0, 1, values[i])\n            currentValues[i] = values[i]\n          }\n        }\n\n        // then the extra memory\n        untracker?.forEachInExtra((_buffer, index, value) => {\n          ctx.save()\n          ctx.globalAlpha = 0.2\n          ctx.fillStyle = 'purple'\n\n          ctx.fillRect(index, 0, 1, value)\n          // repaint the extra values each time\n          currentValues[index] = NaN\n\n          ctx.restore()\n        })\n\n        drawMove()\n      }\n\n      drawFrame()\n\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    },\n    [values, moveRef, untracker]\n  )\n\n  const canvasRef = useCanvas(draw)\n\n  return <canvas className=\"Display\" ref={canvasRef} />\n}\n\nexport default Display\n","import React, { useRef, useEffect } from 'react'\nimport { IconType } from 'react-icons/lib/cjs'\nimport './Button.scss'\n\ntype ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n  name: string\n  handler: () => void\n  disabled?: boolean\n  keyStr?: string\n  keyCode?: number\n}\n\nconst Button: React.FC<ButtonProps> = ({\n  name,\n  handler,\n  disabled,\n  keyStr,\n  keyCode,\n  children,\n  className,\n  ...buttonAttributes\n}) => {\n  const camelCaseName = name\n    .replace(/^(.)/, (_x, y) => y.toLowerCase())\n    .replace(/ (.)/g, (_x, y) => y.toUpperCase())\n\n  // We want to make it possible to specify a keyboard event that will also fire\n  // the button.\n  const ref = useRef<HTMLButtonElement>(null)\n  useEffect(() => {\n    if (keyStr !== undefined || keyCode !== undefined) {\n      const listener = (e: KeyboardEvent) => {\n        // By clicking the button instead of calling the callback, we make sure\n        // that the callback is not fired if the button is disabled\n        if (e.key === keyStr || e.keyCode === keyCode) {\n          ref.current?.click()\n          if (e.key === ' ') e.preventDefault()\n        }\n      }\n      window.addEventListener('keydown', listener)\n      return () => {\n        window.removeEventListener('keydown', listener)\n      }\n    }\n  }, [ref, keyStr, keyCode])\n\n  return (\n    <button\n      ref={ref}\n      className={`Button ${className} ${camelCaseName}`}\n      title={name}\n      onClick={handler}\n      disabled={disabled}\n      {...buttonAttributes}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport const IconButton: React.FC<ButtonProps & { Icon: IconType }> = ({\n  Icon,\n  ...props\n}) => (\n  <Button {...props} className={`${props.className} Icon`}>\n    <Icon className=\"icon\" />\n  </Button>\n)\n\nexport default Button\n","import React, { useState } from 'react'\nimport {\n  FaRedoAlt,\n  FaBackward,\n  FaStepBackward,\n  FaPlay,\n  FaSyncAlt,\n  FaForward,\n  FaStepForward,\n  FaEllipsisV,\n  FaPlus,\n  FaMinus,\n  FaPause,\n  FaInfo\n} from 'react-icons/fa'\nimport Button, { IconButton } from './Button'\nimport './Menu.scss'\n\ninterface ButtonProps {\n  handler: () => void\n  keyStr?: string\n  keyCode?: number\n  disabled?: boolean\n}\n\nconst Menu: React.FC<{\n  reverse: ButtonProps & { status: boolean }\n  restart: ButtonProps\n  speedDown: ButtonProps\n  stepBack: ButtonProps\n  play: ButtonProps & { status: boolean }\n  stepForward: ButtonProps\n  speedUp: ButtonProps\n  stats: ButtonProps\n  sizeUp: ButtonProps\n  sizeDown: ButtonProps\n  unsort: {\n    disabled: boolean\n    list: string[]\n    handler(key: string): void\n  }\n  sort: {\n    current: string\n    list: string[]\n    handler(key: string): void\n  }\n}> = ({\n  reverse: { status: reverseStatus, ...reverse },\n  restart,\n  speedDown,\n  stepBack,\n  play: { status: playStatus, ...play },\n  stepForward,\n  speedUp,\n  stats,\n  sizeUp,\n  sizeDown,\n  unsort,\n  sort\n}) => {\n  const [spinning, setSpinning] = useState(false)\n  const [extra, setExtra] = useState(false)\n\n  return (\n    <div className=\"Menu\">\n      <IconButton\n        name=\"restart\"\n        Icon={FaRedoAlt}\n        style={\n          spinning\n            ? {\n                transition: 'transform 300ms',\n                transform: `rotate(${360}deg)`\n              }\n            : {}\n        }\n        onTransitionEnd={() => setSpinning(false)}\n        {...restart}\n        handler={() => {\n          restart.handler()\n          setSpinning(true)\n        }}\n      />\n      <IconButton name=\"speed down\" Icon={FaBackward} {...speedDown} />\n      <IconButton name=\"step back\" Icon={FaStepBackward} {...stepBack} />\n      <div className=\"playPauseWithReverse\">\n        <IconButton\n          name=\"play\"\n          Icon={playStatus ? FaPause : FaPlay}\n          style={{\n            transition: 'transform 100ms',\n            transform: `rotate(${reverseStatus ? 180 : 0}deg)`\n          }}\n          {...play}\n        />\n        <IconButton name=\"reverse\" Icon={FaSyncAlt} {...reverse} />\n      </div>\n      <IconButton name=\"step forward\" Icon={FaStepForward} {...stepForward} />\n      <IconButton name=\"speed up\" Icon={FaForward} {...speedUp} />\n      <div className={`extra ${extra ? 'show' : 'hide'}`}>\n        <IconButton\n          name=\"extra options\"\n          Icon={FaEllipsisV}\n          keyCode={27}\n          handler={() => setExtra(!extra)}\n        />\n        <div className=\"buttons\">\n          <div className=\"algorithms\">\n            <div className=\"unsort\">\n              {unsort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    unsort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  disabled={unsort.disabled}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n            <div className=\"sort\">\n              {sort.list.map(camelCase => (\n                <Button\n                  key={camelCase}\n                  handler={() => {\n                    setExtra(false)\n                    sort.handler(camelCase)\n                  }}\n                  name={camelCase}\n                  className={sort.current === camelCase ? 'active' : ''}\n                >\n                  {camelCase\n                    .replace(/([A-Z])/g, (_x, y) => ` ${y}`)\n                    .replace(/^(.)/, (_x, y) => y.toUpperCase())}\n                </Button>\n              ))}\n            </div>\n          </div>\n          <IconButton name=\"show stats\" Icon={FaInfo} {...stats} />\n          <IconButton name=\"size up\" Icon={FaPlus} {...sizeUp} />\n          <IconButton name=\"size down\" Icon={FaMinus} {...sizeDown} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default Menu\n","import { useMemo } from 'react'\n\n/**\n * Supplies a sorted array containing the integers from 1 to size.\n *\n * The array reference will change when the size changes.\n */\nconst useValues = (size: number) => {\n  return useMemo(() => {\n    const values = []\n\n    for (let i = 1; i <= size; i++) values.push(i)\n\n    return values\n  }, [size])\n}\n\nexport default useValues\n","export const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const normal = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v)\n  return normal * stddev + mean\n}\n\nexport const boundAndRound = (min: number, target: number, max: number) => {\n  return Math.max(min, Math.min(max, Math.round(target)))\n}\n","import { Algorithm } from '../../types'\nimport cut from './cut'\nimport hinduShuffle from './hindu-shuffle'\nimport overhandShuffle from './overhand-shuffle'\nimport perfectRiffleShuffle from './perfect-riffle-shuffle'\nimport randomise from './randomise'\nimport reverse from './reverse'\nimport riffleShuffle from './riffle-shuffle'\n\nconst algorithms: { [key: string]: Algorithm } = {\n  cut,\n  hinduShuffle,\n  overhandShuffle,\n  perfectRiffleShuffle,\n  randomise,\n  reverse,\n  riffleShuffle\n}\n\nexport default algorithms\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst cut: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 6), size)\n\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n  for (let i = 0; i < size - split; i++) memcpy(split + i, i)\n  for (let i = 0; i < split; i++) memcpy({ buffer, index: i }, size - split + i)\n\n  free(buffer)\n}\n\nexport default cut\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst hinduShuffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  // determine the size of the group to be pulled\n  const group = boundAndRound(0, randomNormal(size / 5, size / 30), size - 1)\n\n  // then determine the first index\n  const start = boundAndRound(\n    0,\n    randomNormal((size - group) / 2, (size - group) / 6),\n    size - group\n  )\n\n  const buffer = malloc(group)\n\n  for (let i = 0; i < group; i++) memcpy(start + i, { buffer, index: i })\n  for (let i = 0; i < start; i++) memcpy(start - i - 1, start + group - i - 1)\n  for (let i = 0; i < group; i++) memcpy({ buffer, index: i }, i)\n\n  free(buffer)\n}\n\nexport default hinduShuffle\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\n/**\n * This shuffle is supposed to represent the normal shuffle that people do with\n * playing cards, and attempts to show the drawbacks of not shuffling properly.\n *\n * You will notice that runs often stay together, and the general order of the\n * entire array tends to reverse after each round\n */\nconst overhand: Algorithm = ({ malloc, memcpy, free, size }) => {\n  let processed = 0\n\n  while (processed < size) {\n    const group = Math.min(\n      size - processed,\n      boundAndRound(0, randomNormal(size / 7, size / 20), size)\n    )\n\n    const buffer = malloc(group)\n    // Copy the group into memory from the back\n    for (let i = 0; i < group; i++) {\n      memcpy(size - group + i, { buffer, index: i })\n    }\n    // Shift the remaining values\n    for (let i = 0; i < size - processed - group; i++) {\n      memcpy(size - group - i - 1, size - i - 1)\n    }\n    // Put the group at the front\n    for (let i = 0; i < group; i++) {\n      memcpy({ buffer, index: i }, processed + i)\n    }\n\n    free(buffer)\n    processed += group\n  }\n}\n\nexport default overhand\n","import { Algorithm } from '../../types'\n\nconst perfectRiffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const halfSize = size >> 1\n  const buffer = malloc(halfSize)\n  for (let i = 0; i < halfSize; i++) memcpy(i, { buffer, index: i })\n\n  let firstHalf = 0\n  let secondHalf = halfSize\n  let destination = 0\n  while (firstHalf < halfSize && secondHalf < size) {\n    memcpy({ buffer, index: firstHalf++ }, destination++)\n    memcpy(secondHalf++, destination++)\n  }\n  free(buffer)\n}\n\nexport default perfectRiffle\n","import { Algorithm } from '../../types'\n\n/**\n * This algorithm does not sort an array - it shuffles an array. The original\n * values will be created sorted; this algorithm will then *un-sort* the values\n * before one of the actual algorithms can sort it.\n */\nconst shuffle: Algorithm = ({ swap, size }) => {\n  for (let i = 0; i < size; i++) {\n    const j = i + Math.floor(Math.random() * (size - i - 1))\n    swap(i, j)\n  }\n}\n\nexport default shuffle\n","import { Algorithm } from '../../types'\n\n/**\n * Does what it says on the tin.\n */\nconst reverse: Algorithm = ({ swap, size }) => {\n  for (let i = 0; i < Math.floor(size / 2); i++) {\n    swap(i, size - i - 1)\n  }\n}\n\nexport default reverse\n","import { Algorithm } from '../../types'\nimport { boundAndRound, randomNormal } from './common'\n\nconst riffle: Algorithm = ({ malloc, memcpy, free, size }) => {\n  const split = boundAndRound(0, randomNormal(size / 2, size / 10), size)\n  const buffer = malloc(split)\n\n  for (let i = 0; i < split; i++) memcpy(i, { buffer, index: i })\n\n  let pA = 0\n  let pB = split\n  let dest = 0\n\n  while (pA < split && pB < size) {\n    if (Math.random() > 0.5) {\n      memcpy({ buffer, index: pA++ }, dest++)\n    } else {\n      memcpy(pB++, dest++)\n    }\n  }\n  // the rest of B is already at the end.\n  while (pA < split) memcpy({ buffer, index: pA++ }, dest++)\n\n  free(buffer)\n}\n\nexport default riffle\n","import { Algorithm } from '../../types'\n\nconst binaryInsertionSort: Algorithm = ({ compare, swap, size }) => {\n  const findIndex = (target: number) => {\n    let low = 0\n    let high = target\n\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n      if (compare(target, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  for (let i = 1; i < size; i++) {\n    const index = findIndex(i)\n    for (let j = i; j > index; j--) {\n      swap(j, j - 1)\n    }\n  }\n}\n\nexport default binaryInsertionSort\n","import { Algorithm } from '../../types'\n\n/**\n * Bubble sort is a sorting algorithm that will sort an array of n comparable\n * elements.\n *\n * Bubble sort works by checking adjacent values. If the right value is less\n * than the left value, it swaps them. Otherwise it leaves them alone.\n *\n * After one pass of the entire array from the end to the beginning, the\n * smallest element in the array will be at the front. Then the pairs are all\n * checked again (but not the definitely sorted part).\n *\n * Since we only have one element sorted each pass, we will have to make a pass\n * for each (next smallest) element in the array, leading to a 'sum of the\n * numbers up to n' style time complexity, which is O(n^2).\n *\n * The space complexity however is very simple, we only keep track of the number\n * of definitely sorted values and our position in the current pass. This means\n * we have O(1) space complexity.\n * @param tracker\n */\nconst bubbleSort: Algorithm = ({ swap, compare, size }) => {\n  for (let i = 0; i < size - 1; i++) {\n    for (let j = size - 1; j > i; j--) {\n      if (compare(j, j - 1) < 0) swap(j, j - 1)\n    }\n  }\n}\n\nexport default bubbleSort\n","import { Algorithm } from '../../types'\n\nconst heapSort: Algorithm = ({ compare, swap, size }) => {\n  const heapify = (current: number, max: number) => {\n    let extreme, left, right\n\n    while (current < max) {\n      extreme = current\n      left = 2 * current + 1\n      right = 2 * current + 2\n\n      if (left < max && compare(extreme, left) < 0) extreme = left\n      if (right < max && compare(extreme, right) < 0) extreme = right\n\n      if (extreme === current) return\n      swap(current, extreme)\n      current = extreme\n    }\n  }\n\n  for (let i = 0; i < size; i++) heapify(size - i - 1, size)\n\n  for (let i = 0; i < size; i++) {\n    swap(0, size - i - 1)\n    heapify(0, size - i - 1)\n  }\n}\n\nexport default heapSort\n","import { Algorithm } from '../../types'\n\nconst mergeSort: Algorithm = ({ compare, malloc, memcpy, free, size }) => {\n  const merge = (low: number, mid: number, high: number) => {\n    const buffer = malloc(high - low)\n\n    let index = 0\n    let i = low\n    let j = mid\n    while (i < mid && j < high) {\n      if (compare(i, j) < 0) memcpy(i++, { buffer, index })\n      else memcpy(j++, { buffer, index })\n      index += 1\n    }\n    // copy remaining values to the end\n    if (i < mid) {\n      for (let k = i; k < mid; k++) {\n        memcpy(k, high - mid + k)\n      }\n    }\n    // copy back from memory\n    while (index--) {\n      memcpy({ buffer, index }, low + index)\n    }\n\n    free(buffer)\n  }\n\n  const split = (low: number, high: number) => {\n    const mid = low + Math.floor((high - low) / 2)\n\n    if (low < mid) {\n      split(low, mid)\n      split(mid, high)\n      merge(low, mid, high)\n    }\n  }\n  split(0, size)\n}\n\nexport default mergeSort\n","import { Algorithm } from '../../types'\n\n/**\n * Quick sort is a recursive sorting algorithm that will sort an array of `n`\n * comparable elements.\n *\n * Quick sort works on subarrays:\n * - It chooses a \"pivot\", any single element in the subarray. The pivot can be\n *   chosen arbitrarily, but difference choices will lead to different runtimes\n *   on different data.\n * - It then partitions the subarray into three portions:\n *   - A subarray of the elements less than or equal to than the pivot;\n *   - The pivot; and,\n *   - A subarray of the elements larger than the pivot.\n * - Then it runs the algorithm again on the two subarrays.\n *\n * Since the subarrays are smaller, the depth will be at most the length of the\n * array (if the smallest value in the array is the first element in every\n * subarray; the array was sorted already) and the sort will finish. Giving us a\n * worst case of O(n^2) time complexity.\n *\n * On average for random data however the split will be closer to the middle and\n * in the best case we will have half the values in each part. Thus in our best\n * case we will have O(n log(n)) time complexity.\n *\n * Since we are recursing, we will have O(1) space for each layer in the\n * recursion, so the worst case for our space complexity will be O(n).\n *\n * In the best case however we will have less layers alive at any one time,\n * meaning our space complexity would be O(log(n)).\n */\nconst quickSort: Algorithm = ({ swap, compare, size }) => {\n  const partition = (low: number, high: number) => {\n    const pivot = low\n\n    let i = high\n    for (let j = high; j > pivot; j--) {\n      if (compare(pivot, j) < 0) swap(j, i--)\n    }\n\n    swap(pivot, i)\n    return i\n  }\n\n  const sort = (low: number, high: number) => {\n    if (low < high) {\n      const mid = partition(low, high)\n      sort(low, mid - 1)\n      sort(mid + 1, high)\n    }\n  }\n\n  sort(0, size - 1)\n}\n\nexport default quickSort\n","import { Algorithm } from '../../types'\n\nconst lsbRadixSort: Algorithm = ({ nthBitSet, malloc, memcpy, free, size }) => {\n  for (let needle = 0; 1 << needle <= size; needle++) {\n    const buffer = malloc(size)\n    let zeroIndex = 0\n    let oneIndex = size - 1\n\n    // partition the values based on their binary representations.\n    for (let i = 0; i < size; i++) {\n      if (nthBitSet(i, needle)) {\n        memcpy(i, { buffer, index: oneIndex-- })\n      } else {\n        memcpy(i, { buffer, index: zeroIndex++ })\n      }\n    }\n\n    // put the values back in order.\n    // first the zeros\n    for (let i = 0; i < zeroIndex; i++) {\n      memcpy({ buffer, index: i }, i)\n    }\n    // then the ones\n    for (let i = 0; i < size - oneIndex; i++) {\n      memcpy({ buffer, index: size - i - 1 }, zeroIndex + i)\n    }\n    free(buffer)\n  }\n}\n\nexport default lsbRadixSort\n","import { Algorithm } from '../../types'\n\n/**\n * The Radix Sort MSB can be performed in-place, while keeing track of the\n * different regions.\n */\nconst msbRadixSort: Algorithm = ({ nthBitSet, swap, size }) => {\n  const loStack = [0]\n  const hiStack = [size]\n  const needleStack = [Math.ceil(Math.log2(size))]\n\n  while (loStack.length > 0) {\n    // if the lostack has a value, the histack will also have a value.\n    const lo = loStack.pop() as number\n    const hi = hiStack.pop() as number\n    const needle = needleStack.pop() as number\n\n    let zero = lo\n    let one = hi\n\n    while (zero < one) {\n      while (zero < one && !nthBitSet(zero, needle)) {\n        zero += 1\n      }\n      while (zero < one && nthBitSet(one, needle)) {\n        one -= 1\n      }\n      swap(zero, one)\n    }\n    // the zero index is now the index of the first one\n    if (lo < zero - 1) {\n      loStack.push(lo)\n      hiStack.push(zero - 1)\n      needleStack.push(needle - 1)\n    }\n    if (zero < hi) {\n      loStack.push(zero)\n      hiStack.push(hi)\n      needleStack.push(needle - 1)\n    }\n  }\n}\n\nexport default msbRadixSort\n","import { Algorithm } from '../../types'\n\nconst shellSort: Algorithm = ({ compare, swap, size }) => {\n  let gap = ~~(size / 2)\n\n  while (gap > 0) {\n    for (let i = gap; i < size; i++) {\n      for (let j = i; j >= gap && compare(j - gap, j) > 0; j -= gap) {\n        swap(j - gap, j)\n      }\n    }\n    gap = ~~(gap / 2)\n  }\n}\n\nexport default shellSort\n","import { Algorithm, Index } from '../../types'\n\ninterface Slice {\n  base: number\n  len: number\n}\n\nclass MergeState {\n  pending: Slice[] = []\n  minGallop = 7\n}\n\n/**\n * Adapted from the listsort algorithm in python\n * http://svn.python.org/projects/python/trunk/Objects/listobject.c\n */\nconst timsort: Algorithm = ({ compare, swap, malloc, memcpy, free, size }) => {\n  /**\n   * Returns the length of a run starting at a given index (up to a given\n   * index).\n   *\n   * If the run is descending the value will be the negative length of the run.\n   */\n  const countRun = (low: number, high: number) => {\n    if (low === high - 1) return 1\n    let n = low + 1\n    if (compare(low, n) > 0) {\n      while (n < high && compare(n - 1, n) > 0) n++\n      // returns negative to signify decending run\n      return low - n\n    }\n    while (n < high && compare(n - 1, n) <= 0) n++\n    return n - low\n  }\n\n  /**\n   * Simmilar to binary search, except first finds a good lower and upper bound\n   * before searching.\n   */\n  const gallopLeft = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      // mark should be somwhere in [hint, size]\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset = hint + lastOffset\n      offset = hint + offset\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n    return offset\n  }\n\n  const gallopRight = (\n    mark: number | Index,\n    from: number,\n    length: number,\n    hint: number,\n    /** optionally set the buffer that from should access */\n    fromBuffer?: number\n  ) => {\n    /** Wraps an index to from with the specified buffer if needed. */\n    const indexFrom = fromBuffer\n      ? (index: number) => ({ buffer: fromBuffer, index })\n      : (index: number) => index\n    const base = from + hint\n    let lastOffset = 0\n    let offset = 1\n\n    if (compare(indexFrom(base), mark) < 0) {\n      const maxOffset = length - hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base + offset), mark) < 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base\n      lastOffset += hint\n      offset += hint\n    } else {\n      const maxOffset = hint\n      while (\n        offset < maxOffset &&\n        compare(indexFrom(base - offset), mark) >= 0\n      ) {\n        lastOffset = offset\n        offset = (offset << 1) + 1\n        if (offset <= 0) offset = maxOffset\n      }\n      if (offset > maxOffset) offset = maxOffset\n      // translate so that offset is relative to from not base and lastOffset <\n      // offset\n      const temp = lastOffset\n      lastOffset = hint - offset\n      offset = hint - temp\n    }\n\n    while (lastOffset < offset) {\n      const mid = lastOffset + ((offset - lastOffset) >> 1)\n      if (compare(indexFrom(from + mid), mark) < 0) lastOffset = mid + 1\n      else offset = mid\n    }\n\n    return offset\n  }\n\n  /**\n   * Finds the index of a value (or the index a value should be inserted at) in\n   * sorted data.\n   */\n  const binarySearch = (low: number, high: number, mark: number) => {\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2)\n\n      if (compare(mark, mid) < 0) high = mid\n      else low = mid + 1\n    }\n\n    return low\n  }\n\n  /**\n   * Shifts values to the right, wrapping the last value to the front.\n   */\n  const shift = (low: number, high: number) => {\n    for (let i = high; i > low; i--) swap(i - 1, i)\n  }\n\n  /**\n   * Performs a binary insertion sort on a chunk.\n   */\n  const insertionSort = (low: number, high: number) => {\n    for (let i = low; i < high; i++) shift(binarySearch(low, i, i), i)\n  }\n\n  /**\n   * Reverses a chunk.\n   */\n  const reverse = (low: number, high: number) => {\n    const mid = Math.floor((high - low) / 2)\n    for (let i = 0; i < mid; i++) swap(low + i, high - i - 1)\n  }\n\n  /**\n   * Timsort's merge low method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeLo = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the A buffer into extra memory\n    const buffer = malloc(nA)\n    for (let index = 0; index < nA; index++) {\n      memcpy(pA + index, { buffer, index })\n    }\n\n    let destination = pA\n    pA = 0 // this is now the index in extra memory\n    let countA = 0\n    let countB = 0\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n\n        countA = gallopRight(pB, pA, nA, 0, buffer)\n        for (let i = 0; i < countA; i++) {\n          memcpy({ buffer, index: pA++ }, destination++)\n        }\n        nA -= countA\n        // if (nA === 0) return\n\n        countB = gallopLeft({ buffer, index: pA }, pB, nB, 0)\n        for (let i = 0; i < countB; i++) {\n          memcpy(pB++, destination++)\n        }\n        nB -= countB\n        // if (nB === 0) return\n      }\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: pA }, pB) < 0) {\n        memcpy({ buffer, index: pA++ }, destination++)\n        nA -= 1\n        countA += 1\n        countB = 0\n      } else {\n        memcpy(pB++, destination++)\n        nB -= 1\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n\n    while (nA-- > 0) memcpy({ buffer, index: pA++ }, destination++)\n\n    free(buffer)\n  }\n\n  /**\n   * Timsort's merge high method\n   *\n   * @param pA The first index of the A buffer\n   * @param nA The length of the A buffer\n   * @param pB The first index of the B buffer\n   * @param nB the length of the B buffer\n   */\n  const mergeHi = (\n    mergeState: MergeState,\n    pA: number,\n    nA: number,\n    pB: number,\n    nB: number\n  ) => {\n    // copy the B buffer into memory\n    const buffer = malloc(nB)\n    for (let index = 0; index < nB; index++) {\n      memcpy(pB + index, { buffer, index })\n    }\n\n    let destination = pB + nB\n    let countA = 0 // number of times A won in a row\n    let countB = 0 // number of times B won in a row\n\n    const gallop = () => {\n      while (\n        nA > 0 &&\n        nB > 0 &&\n        (countA >= mergeState.minGallop || countB >= mergeState.minGallop)\n      ) {\n        if (mergeState.minGallop) mergeState.minGallop -= 1\n        countA = nA - gallopRight({ buffer, index: nB - 1 }, pA, nA, nA - 1)\n        for (let i = 0; i < countA; i++) {\n          memcpy(pA + --nA, --destination)\n        }\n        // if (nA === 0) return\n\n        countB = nB - gallopLeft(pA + nA - 1, 0, nB, nB - 1, buffer)\n        for (let i = 0; i < countB; i++) {\n          memcpy({ buffer, index: --nB }, --destination)\n        }\n        // if (nB === 0) return\n      }\n      // punishment for not gallopping anymore\n      mergeState.minGallop += 1\n    }\n\n    while (nA > 0 && nB > 0) {\n      if (compare({ buffer, index: nB - 1 }, pA + nA - 1) <= 0) {\n        memcpy(pA + --nA, --destination)\n        countA += 1\n        countB = 0\n      } else {\n        memcpy({ buffer, index: --nB }, --destination)\n        countA = 0\n        countB += 1\n      }\n      // One run is winning so consistently that galloping may be a huge win.\n      if (countA + countB >= mergeState.minGallop) gallop()\n    }\n    while (nB > 0) memcpy({ buffer, index: --nB }, --destination)\n\n    free(buffer)\n  }\n\n  /** Merges two slices */\n  const mergeAt = (mergeState: MergeState, i: number) => {\n    const { pending } = mergeState\n    let pA = pending[i].base\n    let nA = pending[i].len\n    const pB = pending[i + 1].base\n    let nB = pending[i + 1].len\n\n    // record the length of the combined runs.\n    pending[i].len = nA + nB\n    // remove the chunk that will be merged.\n    pending.splice(i + 1, 1)\n\n    // Where does b start in a? Elements before that can be ignored.\n    const ignoreAtFront = gallopRight(pB, pA, nA, 0)\n    pA += ignoreAtFront\n    nA -= ignoreAtFront\n\n    nB = gallopLeft(pA + nA - 1, pB, nB, nB - 1)\n\n    const merge = nA <= nB ? mergeLo : mergeHi\n    merge(mergeState, pA, nA, pB, nB)\n  }\n\n  const mergeCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len <= pending[n].len + pending[n + 1].len) {\n        if (pending[n - 1].len < pending[n + 1].len) n -= 1\n        mergeAt(mergeState, n)\n      } else if (pending[n].len <= pending[n + 1].len) {\n        mergeAt(mergeState, n)\n      } else break\n    }\n  }\n\n  const mergeForceCollapse = (mergeState: MergeState) => {\n    const { pending } = mergeState\n    while (pending.length > 1) {\n      let n = pending.length - 2\n      if (n > 0 && pending[n - 1].len < pending[n + 1].len) n -= 1\n      mergeAt(mergeState, n)\n    }\n  }\n\n  /** Calculates the optimal minimum length of a run. */\n  const calculateMinRun = (length: number) => {\n    let r = 0 // becomes 1 if any 1 bits are shifted off.\n\n    // The true version of timsort uses 64 as a max, min size, we will use 16 so\n    // that the merging can be seen at smaller sizes\n    // while (length >= 64) {\n    while (length >= 16) {\n      r |= length & 1\n      length >>= 1\n    }\n\n    return length + r\n  }\n\n  const mergeState = new MergeState()\n  let remaining = size\n  let low = 0\n\n  const MIN_RUN = calculateMinRun(size)\n  while (remaining > 0) {\n    let n = countRun(low, size)\n\n    // reverse if descending\n    if (n < 0) {\n      n *= -1\n      reverse(low, low + n)\n    }\n\n    // exdend if too short\n    if (n < MIN_RUN) {\n      n = Math.min(MIN_RUN, remaining)\n      insertionSort(low, low + n)\n    }\n\n    // push run onto pending stack and maybe merge\n    mergeState.pending.push({\n      base: low,\n      len: n\n    })\n    mergeCollapse(mergeState)\n\n    low += n\n    remaining -= n\n  }\n  mergeForceCollapse(mergeState)\n}\n\nexport default timsort\n","import { Algorithm } from '../../types'\nimport binaryInsertionSort from './binary-insertion-sort'\nimport bubbleSort from './bubble-sort'\nimport heapSort from './heap-sort'\nimport mergeSort from './merge-sort'\n// import pancakeSort from './pancake-sort'\nimport quickSort from './quick-sort'\nimport radixSortLsb from './radix-sort-lsb'\nimport radixSortMsb from './radix-sort-msb'\nimport shellSort from './shell-sort'\nimport timsort from './tim-sort'\n\nconst algorithms: { [key: string]: Algorithm } = {\n  binaryInsertionSort,\n  bubbleSort,\n  heapSort,\n  mergeSort,\n  // pancakeSort,\n  quickSort,\n  radixSortLsb,\n  radixSortMsb,\n  shellSort,\n  timsort\n}\n\nexport default algorithms\n","import { Move, MoveType } from './types'\n\nexport default class StatTracker {\n  comparisons = 0\n  reads = 0\n  writes = 0\n\n  private modifyBy(move: Move, multiplier: number) {\n    switch (move.type) {\n      case MoveType.COMPARE:\n        this.reads += 2 * multiplier\n        this.comparisons += 1 * multiplier\n        break\n      case MoveType.SWAP:\n        this.reads += 2 * multiplier\n        this.writes += 2 * multiplier\n        break\n      case MoveType.MALLOC:\n        break\n      case MoveType.MEMCPY:\n        this.reads += 1 * multiplier\n        this.writes += 1 * multiplier\n        break\n      case MoveType.FREE:\n        break\n      case MoveType.NTH_BIT_SET:\n        this.reads += 1 * multiplier\n        break\n    }\n  }\n\n  add(move: Move) {\n    this.modifyBy(move, 1)\n  }\n\n  subtract(move: Move) {\n    this.modifyBy(move, -1)\n  }\n}\n","import { MoveType, Move, Direction } from './types'\nimport StatTracker from './StatTracker'\n\n/**\n * Just as the Tracker class is for recording the algorithms. The UnTracker is\n * for replaying a tracker.\n */\nexport default class Untracker {\n  private original: number[]\n  private buffers: {\n    [key: number]: number[]\n  }\n  private bufferIds: Set<number>\n  private moves: Move[]\n  private currentMove: number\n  statistics: StatTracker\n\n  constructor(moves: Move[], values: number[], original: number[]) {\n    this.moves = moves\n    this.buffers = {\n      0: values\n    }\n    this.bufferIds = new Set()\n    this.original = original\n\n    // A tracker is not expected to undo any of the moves that were performed on\n    // the data. The untracker has to take this into account, so by default will\n    // be finished.\n    this.currentMove = 0\n\n    this.statistics = new StatTracker()\n\n    this.hasNext = this.hasNext.bind(this)\n    this.hasPrevious = this.hasPrevious.bind(this)\n    this.next = this.next.bind(this)\n    this.previous = this.previous.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  /** Returns true if there is a future move available to do. */\n  private hasNext() {\n    return this.currentMove < this.moves.length\n  }\n\n  /** Returns true if there is a previous move available to undo. */\n  private hasPrevious() {\n    return this.currentMove > 0\n  }\n\n  next() {\n    if (!this.hasNext()) return\n\n    const move = this.moves[this.currentMove++]\n\n    this.statistics.add(move)\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = j.value\n          this.buffers[j.buffer][j.index] = i.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n          this.buffers[buffer] = []\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const { from, to } = move\n\n          const value = this.buffers[from.buffer][from.index]\n          this.buffers[to.buffer][to.index] = value\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  previous() {\n    if (!this.hasPrevious()) return\n\n    const move = this.moves[--this.currentMove]\n\n    this.statistics.subtract(move)\n\n    switch (move.type) {\n      case MoveType.SWAP:\n        {\n          const { i, j } = move\n          this.buffers[i.buffer][i.index] = i.value\n          this.buffers[j.buffer][j.index] = j.value\n        }\n        break\n      case MoveType.MALLOC:\n        {\n          const { buffer } = move\n          this.bufferIds.delete(buffer)\n        }\n        break\n      case MoveType.MEMCPY:\n        {\n          const {\n            to: { buffer, index },\n            original\n          } = move\n\n          this.buffers[buffer][index] = original\n        }\n        break\n      case MoveType.FREE:\n        {\n          const { buffer } = move\n          this.bufferIds.add(buffer)\n        }\n        break\n    }\n\n    return move\n  }\n\n  /** Returns the values array to its original state. */\n  reset() {\n    // delete the extra buffers\n    this.bufferIds.forEach(id => {\n      delete this.buffers[id]\n    })\n\n    for (let i = 0; i < this.original.length; i++) {\n      this.buffers[0][i] = this.original[i]\n    }\n\n    this.currentMove = 0\n  }\n\n  /** Advances the untracker in a direction determined by the reverse boolean */\n  step(direction: Direction) {\n    return direction === Direction.FORWARD ? this.next() : this.previous()\n  }\n\n  /**\n   * Returns true if the untracker has a valid move available in the determined\n   * direction\n   */\n  hasStep(direction: Direction) {\n    return direction === Direction.FORWARD ? this.hasNext() : this.hasPrevious()\n  }\n\n  /**\n   * Animates the advancement of steps in a given direction.\n   *\n   * @param stepsPerFrame The number of steps to be advanced per frame\n   * @param onCompletion A callback to be run if all of the steps have been\n   * completed.\n   */\n  animateStepsPerFrame(\n    stepsPerFrame: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const { onCompletion, moveRef } = options\n\n    const base = (stepsPerFrame: number) => {\n      for (let i = 0; i < stepsPerFrame; i++) this.step(direction)\n    }\n\n    // if the moveRef is defined then record the last move\n    const withRecord = moveRef\n      ? () => {\n          base(stepsPerFrame - 1)\n          moveRef.current = this.step(direction)\n        }\n      : () => base(stepsPerFrame)\n\n    const withAnimationFrame = () => {\n      let frame: number\n      const run = () => {\n        withRecord()\n        if (this.hasStep(direction)) frame = requestAnimationFrame(run)\n        else if (onCompletion) onCompletion()\n      }\n      run()\n      return () => {\n        cancelAnimationFrame(frame)\n      }\n    }\n    const withInterval = () => {\n      const interval = setInterval(() => {\n        withRecord()\n        if (!this.hasStep(direction)) {\n          clearInterval(interval)\n          if (onCompletion) onCompletion()\n        }\n      }, 1 / (0.06 * stepsPerFrame))\n      return () => {\n        clearInterval(interval)\n      }\n    }\n\n    return stepsPerFrame >= 1 ? withAnimationFrame() : withInterval()\n  }\n\n  animateUntilCompletion(\n    timeUntilCompletion: number,\n    direction: Direction,\n    options: {\n      onCompletion?: () => void\n      moveRef?: React.MutableRefObject<Move | undefined>\n    } = {}\n  ) {\n    const stepsRemaining =\n      direction === Direction.FORWARD\n        ? this.moves.length - this.currentMove\n        : this.currentMove\n\n    // there are 0.06 frames per millisecond\n    const stepsPerFrame = stepsRemaining / (timeUntilCompletion * 0.06)\n\n    return this.animateStepsPerFrame(stepsPerFrame, direction, options)\n  }\n\n  forEachInExtra(\n    callback: (buffer: number, index: number, value: number) => void\n  ) {\n    this.bufferIds.forEach(buffer => {\n      this.buffers[buffer].forEach((value, index) =>\n        callback(buffer, index, value)\n      )\n    })\n  }\n}\n","import { MoveType, Move, Index } from './types'\nimport Untracker from './Untracker'\n\nclass BufferIdPool {\n  private _next = 1\n  private _inUse: Set<number> = new Set([])\n\n  next(): number {\n    const id = this._next++\n    this._inUse.add(id)\n    return id\n  }\n\n  free(id: number) {\n    this._inUse.delete(id)\n  }\n\n  inUse(id: number) {\n    return this._inUse.has(id)\n  }\n\n  /** Iterates over the keys in use. */\n  [Symbol.iterator]() {\n    return this._inUse[Symbol.iterator]()\n  }\n}\n\n/**\n * Abstracts the values array to the sorting algorithm so that the moves can be\n * monitored and recorded.\n */\nexport default class Tracker {\n  /** A copy of the original values that the Tracker was instantiated with. */\n  private original: number[]\n  /** A list of the current buffers in use for the sort. */\n  private buffers: {\n    /** The main values array */\n    0: number[]\n    [key: number]: number[]\n  }\n  /** An object that will give and keep track of unique keys. */\n  private bufferIdPool: BufferIdPool\n  /** The moves that have been done to the values. */\n  private moves: Move[]\n  /** The length of the values array. */\n  readonly size: number\n\n  constructor(values: number[]) {\n    this.original = [...values]\n    this.buffers = {\n      0: values\n    }\n    this.bufferIdPool = new BufferIdPool()\n    this.size = values.length\n    this.moves = []\n\n    this.swap = this.swap.bind(this)\n    this.compare = this.compare.bind(this)\n    this.malloc = this.malloc.bind(this)\n    this.memcpy = this.memcpy.bind(this)\n    this.free = this.free.bind(this)\n    this.nthBitSet = this.nthBitSet.bind(this)\n  }\n\n  /**\n   * Returns an untracker with the moves tracked by the tracker.\n   *\n   * @param values The array to modify while untracking\n   */\n  untrack(values = this.buffers[0]) {\n    return new Untracker(this.moves, values, this.original)\n  }\n\n  /**\n   * Swaps the values at indicies i and j.\n   */\n  swap(iIndex: Index | number, jIndex: Index | number): void {\n    // normalise the inputs\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const iBuffer = this.buffers[i.buffer]\n    const jBuffer = this.buffers[j.buffer]\n\n    iBuffer[i.index] = j.value\n    jBuffer[j.index] = i.value\n\n    this.moves.push({ type: MoveType.SWAP, i, j })\n  }\n\n  /**\n   * Compares the values at indicies i and j and returns:\n   *\n   * - **-1** If the value at i is less than the value at j;\n   * - **0** If the value at i is equal to the value at j; or,\n   * - **1** If the value at i is greater than the value at j.\n   */\n  compare(iIndex: Index | number, jIndex: Index | number) {\n    const i = this.normaliseIndex(iIndex)\n    const j = this.normaliseIndex(jIndex)\n\n    const result = Math.sign(i.value - j.value)\n\n    this.moves.push({ type: MoveType.COMPARE, i, j, result })\n\n    return result\n  }\n\n  /**\n   * Comparable to the C malloc function, however instead of returning a pointer\n   * to the allocated buffer, will return an id to the buffer that was\n   * allocated.\n   */\n  malloc(size: number) {\n    const buffer = this.bufferIdPool.next()\n\n    this.buffers[buffer] = new Array(size)\n\n    this.moves.push({ type: MoveType.MALLOC, size, buffer })\n\n    return buffer\n  }\n\n  /**\n   * Copies a value from one buffer to another.\n   */\n  memcpy(from: Index | number, to: Index | number) {\n    from = this.normaliseIndex(from)\n    to = this.normaliseIndex(to)\n\n    // copy\n    const value = this.buffers[from.buffer][from.index]\n\n    // remember\n    const original = this.buffers[to.buffer][to.index]\n\n    // paste\n    this.buffers[to.buffer][to.index] = value\n\n    this.moves.push({ type: MoveType.MEMCPY, from, to, value, original })\n  }\n\n  /**\n   * Releases a chunk of memory.\n   *\n   * @param buffer The id of the buffer to free.\n   */\n  free(buffer: number) {\n    // we cant free the main values\n    if (buffer > 0) {\n      delete this.buffers[buffer]\n      this.bufferIdPool.free(buffer)\n      this.moves.push({ type: MoveType.FREE, buffer })\n    }\n  }\n\n  /**\n   * Returns a boolean that is true if and only if the nth (little endian) bit\n   * of the value at a given index is set.\n   *\n   * @param givenIndex The index of the value to check.\n   * @param n The bit (little endian) of the value to check.\n   */\n  nthBitSet(givenIndex: Index | number, n: number) {\n    const index = this.normaliseIndex(givenIndex)\n\n    const result = Boolean(index.value & (1 << n))\n\n    this.moves.push({ type: MoveType.NTH_BIT_SET, index, result })\n\n    return result\n  }\n\n  /**\n   * Normalises an index so that it has a buffer property. Most of the functions\n   * will work by just passing a number as the index, which should index the\n   * main values array.\n   */\n  private normaliseIndex(index: Index | number): Index & { value: number } {\n    if (typeof index === 'number') index = { buffer: 0, index }\n    const value = this.buffers[index.buffer][index.index]\n    return { ...index, value }\n  }\n}\n","import { useState, useCallback, useEffect } from 'react'\nimport unsortingAlgorithms from '../../sort/algorithms/unsort'\nimport sortingAlgorithms from '../../sort/algorithms/sort'\nimport Tracker from '../../sort/Tracker'\nimport Untracker from '../../sort/Untracker'\nimport { Direction } from '../../sort/types'\n\nconst useAlgorithms = (values: number[]) => {\n  /**\n   * The original values will be displayed on the screen.\n   *\n   * This array is intended to be modified by the unsorting algorithm so that\n   * the unsort can be untracked on the original values, and the sort can be\n   * calculated while the unsort is running.\n   */\n  const [unsortedValues, setUnsortedValues] = useState([...values])\n  useEffect(() => setUnsortedValues([...values]), [values])\n\n  const unsortWith = useCallback(\n    (name: string, block?: () => void, unblock?: () => void) => {\n      if (name === 'nothing') {\n        setUnsortedValues([...values])\n        return\n      }\n      if (!(name in unsortingAlgorithms)) return\n\n      if (block && unblock) block()\n\n      const copy = [...values]\n      const tracker = new Tracker(copy)\n\n      unsortingAlgorithms[name](tracker)\n\n      setUnsortedValues(copy)\n      const untracker = tracker.untrack(values)\n\n      untracker.animateUntilCompletion(500, Direction.FORWARD, {\n        onCompletion: () => {\n          if (unblock) unblock()\n        }\n      })\n    },\n    [values]\n  )\n\n  /** A string identifying the currently in use sort. */\n  const [sortString, setSortString] = useState('heapSort')\n\n  /** The untracker for the sort */\n  const [sortUntracker, setSortUntracker] = useState<Untracker>()\n\n  useEffect(() => {\n    let invalid = false\n\n    const calculate = async () => {\n      if (!(sortString in sortingAlgorithms)) return\n      const tracker = new Tracker(unsortedValues)\n\n      // if calculation is made async we can put an await in front of this.\n      sortingAlgorithms[sortString](tracker)\n\n      const untracker = tracker.untrack(values)\n\n      return untracker\n    }\n\n    calculate().then(untracker => !invalid && setSortUntracker(untracker))\n\n    return () => {\n      invalid = true\n    }\n  }, [sortString, unsortedValues, values])\n\n  const setSort = useCallback((name: string) => {\n    setSortString(name)\n  }, [])\n\n  return {\n    unsortWith,\n    sort: sortUntracker,\n    setSort,\n    sortString\n  }\n}\n\nexport default useAlgorithms\n","import { useState, useCallback } from 'react'\n\n/** Toggles between two values */\nfunction useToggle<T>(first: T, second: T): [T, (set?: T) => void] {\n  const [value, setValue] = useState(true)\n  const toggle = useCallback(\n    (firstOrSecond?: T) => {\n      if (firstOrSecond === first) setValue(true)\n      else if (firstOrSecond === second) setValue(false)\n      else setValue(value => !value)\n    },\n    [first, second]\n  )\n\n  return [value ? first : second, toggle]\n}\n\nexport default useToggle\n","import { useState, useCallback, useMemo } from 'react'\n\nconst useBlock = () => {\n  const [count, setCount] = useState(0)\n\n  const blocking = count > 0\n  const block = useCallback(() => {\n    setCount(count => count + 1)\n  }, [])\n\n  const unblock = useCallback(() => {\n    setCount(count => Math.max(0, count - 1))\n  }, [])\n\n  return useMemo(() => ({ blocking, block, unblock }), [\n    blocking,\n    block,\n    unblock\n  ])\n}\n\nexport default useBlock\n","import React, { useEffect, useState } from 'react'\nimport StatTracker from '../../sort/StatTracker'\nimport './Stats.scss'\n\nconst Stats: React.FC<{\n  stats?: StatTracker\n  display: boolean\n}> = ({ stats = { comparisons: 0, reads: 0, writes: 0 }, display }) => {\n  const [comparisons, setComparisons] = useState(stats.comparisons)\n  const [reads, setReads] = useState(stats.reads)\n  const [writes, setWrites] = useState(stats.writes)\n\n  /** update the values if they have changed  */\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setComparisons(stats.comparisons)\n      setReads(stats.reads)\n      setWrites(stats.writes)\n    }, 50)\n    return () => clearInterval(interval)\n  }, [stats])\n\n  return (\n    <div className={`Stats ${display ? 'show' : 'hide'}`}>\n      <div className=\"stat comparisons\">Comparisons: {comparisons}</div>\n      <div className=\"stat reads\">Reads: {reads}</div>\n      <div className=\"stat writes\">Writes: {writes}</div>\n    </div>\n  )\n}\n\nexport default Stats\n","import React, { useState, useEffect, useRef } from 'react'\nimport Display from './components/Display'\nimport Menu from './components/Menu'\nimport useValues from './hooks/use-values'\nimport useAlgorithms from './hooks/use-algorithms'\nimport useToggle from './hooks/use-toggle'\nimport useBlock from './hooks/use-block'\nimport sortingAlgorithms from '../sort/algorithms/sort'\nimport unsortingAlgorithms from '../sort/algorithms/unsort'\nimport { Direction, Move } from '../sort/types'\nimport './App.scss'\nimport Stats from './components/Stats'\n\nconst App: React.FC = () => {\n  const [direction, changeDirection] = useToggle(\n    Direction.FORWARD,\n    Direction.BACKWARD\n  )\n  const [play, setPlay] = useState(false)\n  const [displayStats, setDisplayStats] = useState(false)\n  const { blocking, block, unblock } = useBlock()\n\n  /** The number of steps per frame is exponential in speed */\n  const minSpeed = -10\n  const maxSpeed = 10\n  const [speed, setSpeed] = useState(-4)\n\n  /** The length of the values array is exponantial in size */\n  const minSize = 3\n  const maxSize = 20\n  const [size, setSize] = useState(12)\n\n  const values = useValues(Math.floor(Math.pow(1.5, size)))\n\n  const { unsortWith, sort, setSort, sortString } = useAlgorithms(values)\n\n  const moveRef = useRef<Move | undefined>()\n  useEffect(() => {\n    moveRef.current = undefined\n    // Any blocking action occurring will refresh the current move.\n  }, [moveRef, blocking])\n\n  useEffect(() => {\n    if (play) {\n      return sort?.animateStepsPerFrame(Math.pow(1.3, speed), direction, {\n        onCompletion: () => {\n          setPlay(false)\n          changeDirection()\n          moveRef.current = undefined\n        },\n        moveRef\n      })\n    }\n  }, [play, sort, speed, direction, changeDirection, moveRef])\n\n  return (\n    <div className=\"App\">\n      <Menu\n        restart={{\n          disabled: blocking || !sort,\n          keyStr: 'r',\n          handler: () => {\n            changeDirection(Direction.FORWARD)\n            setPlay(false)\n            block()\n\n            sort?.animateUntilCompletion(1000, Direction.BACKWARD, {\n              onCompletion: () => unblock()\n            })\n          }\n        }}\n        speedDown={{\n          disabled: blocking || !sort,\n          // if playing leftArrow decreases speed\n          keyCode: play ? 37 : undefined,\n          handler: () => setSpeed(Math.max(minSpeed, speed - 1))\n        }}\n        stepBack={{\n          disabled: blocking || !sort,\n          // if not playing leftArrow steps back\n          keyCode: play ? undefined : 37,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.BACKWARD)\n          }\n        }}\n        play={{\n          disabled: blocking || !sort,\n          handler: () => setPlay(!play),\n          keyStr: ' ',\n          status: play\n        }}\n        reverse={{\n          disabled: blocking || !sort,\n          keyStr: '`',\n          handler: () => {\n            const oppositeDirection =\n              direction === Direction.BACKWARD\n                ? Direction.FORWARD\n                : Direction.BACKWARD\n            if (sort?.hasStep(oppositeDirection)) changeDirection()\n          },\n          status: direction === Direction.BACKWARD\n        }}\n        stepForward={{\n          disabled: blocking || !sort,\n          // if not playing rightArrow steps forward\n          keyCode: play ? undefined : 39,\n          handler: () => {\n            moveRef.current = sort?.step(Direction.FORWARD)\n          }\n        }}\n        speedUp={{\n          disabled: blocking || !sort,\n          // if playing rightArrow increases speed\n          keyCode: play ? 39 : undefined,\n          handler: () => setSpeed(Math.min(maxSpeed, speed + 1))\n        }}\n        stats={{\n          keyStr: 's',\n          handler: () => setDisplayStats(v => !v)\n        }}\n        sizeUp={{\n          keyCode: 38,\n          handler: () => setSize(Math.min(maxSize, size + 1))\n        }}\n        sizeDown={{\n          keyCode: 40,\n          handler: () => setSize(Math.max(minSize, size - 1))\n        }}\n        unsort={{\n          disabled: blocking,\n          list: Object.keys(unsortingAlgorithms),\n          handler: algorithm => {\n            if (algorithm in unsortingAlgorithms) {\n              setPlay(false)\n              changeDirection(Direction.FORWARD)\n\n              unsortWith(algorithm, block, unblock)\n            }\n          }\n        }}\n        sort={{\n          current: sortString,\n          list: Object.keys(sortingAlgorithms),\n          handler: algorithm => {\n            if (algorithm in sortingAlgorithms && algorithm !== sortString) {\n              moveRef.current = undefined\n              unsortWith('nothing')\n              setSort(algorithm)\n            }\n          }\n        }}\n      />\n      <Stats stats={sort?.statistics} display={displayStats} />\n      <Display values={values} moveRef={moveRef} untracker={sort} />\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './ui/App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}